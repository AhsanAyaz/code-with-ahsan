---
phase: 07-projects-demos-templates
plan: 06
type: execute
wave: 2
depends_on: ["07-05"]
files_modified:
  - src/app/api/projects/showcase/route.ts
  - src/app/projects/showcase/page.tsx
  - src/components/projects/ShowcaseCard.tsx
  - src/components/projects/ShowcaseFilters.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Public /projects/showcase page displays completed projects with demos"
    - "Showcase page fetches completed projects from dedicated API endpoint"
    - "Showcase cards show project title, description, tech stack, creator, and demo link"
    - "Showcase is filterable by tech stack"
    - "Showcase is sortable by completion date (newest first default, toggle to oldest)"
    - "Showcase page is accessible without authentication"
  artifacts:
    - path: "src/app/api/projects/showcase/route.ts"
      provides: "GET endpoint returning completed projects ordered by completedAt desc"
      exports: ["GET"]
    - path: "src/app/projects/showcase/page.tsx"
      provides: "Public showcase page with project grid and filters"
      contains: "ShowcaseCard"
    - path: "src/components/projects/ShowcaseCard.tsx"
      provides: "Card component for showcase display with demo link"
      contains: "demoUrl"
    - path: "src/components/projects/ShowcaseFilters.tsx"
      provides: "Filter UI for tech stack and completion date sorting"
      contains: "techFilter"
  key_links:
    - from: "src/app/projects/showcase/page.tsx"
      to: "/api/projects/showcase"
      via: "fetch on mount"
      pattern: "fetch.*api/projects/showcase"
    - from: "src/app/projects/showcase/page.tsx"
      to: "src/components/projects/ShowcaseCard.tsx"
      via: "import and render in grid"
      pattern: "import.*ShowcaseCard"
    - from: "src/app/projects/showcase/page.tsx"
      to: "src/components/projects/ShowcaseFilters.tsx"
      via: "import and render above grid"
      pattern: "import.*ShowcaseFilters"
---

<objective>
Create the public showcase page for completed projects with demos, including API endpoint, showcase cards, and filtering by tech stack and completion date.

Purpose: Satisfy DEMO-03 (public showcase displays completed projects) and DEMO-04 (filterable by tech stack and completion date). The showcase is the public-facing output of the project collaboration system.

Output: API endpoint, showcase page component, showcase card component, and filter component.
</objective>

<execution_context>
@/Users/amu1o5/.claude/get-shit-done/workflows/execute-plan.md
@/Users/amu1o5/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/types/mentorship.ts
@src/app/api/projects/route.ts
@src/app/projects/discover/page.tsx
@src/components/projects/ProjectCard.tsx
@src/components/projects/ProjectFilters.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create showcase API endpoint and ShowcaseCard component</name>
  <files>src/app/api/projects/showcase/route.ts, src/components/projects/ShowcaseCard.tsx</files>
  <action>
1. Create `src/app/api/projects/showcase/route.ts`:

```typescript
import { NextRequest, NextResponse } from "next/server";
import { db } from "@/lib/firebaseAdmin";

export async function GET(request: NextRequest) {
  try {
    // Fetch completed projects, ordered by completedAt descending
    const snapshot = await db
      .collection("projects")
      .where("status", "==", "completed")
      .orderBy("completedAt", "desc")
      .get();

    const projects = snapshot.docs.map((doc) => {
      const data = doc.data();
      return {
        id: doc.id,
        title: data.title,
        description: data.description,
        creatorId: data.creatorId,
        creatorProfile: data.creatorProfile || null,
        status: data.status,
        techStack: data.techStack || [],
        difficulty: data.difficulty,
        maxTeamSize: data.maxTeamSize,
        memberCount: data.memberCount || 0,
        githubRepo: data.githubRepo || null,
        demoUrl: data.demoUrl || null,
        demoDescription: data.demoDescription || null,
        templateId: data.templateId || null,
        completedAt: data.completedAt?.toDate?.()?.toISOString() || null,
        createdAt: data.createdAt?.toDate?.()?.toISOString() || null,
      };
    });

    return NextResponse.json({ projects }, { status: 200 });
  } catch (error) {
    console.error("Error fetching showcase projects:", error);
    return NextResponse.json(
      { error: "Failed to fetch showcase projects" },
      { status: 500 }
    );
  }
}
```

This is a public endpoint - no authentication required. It returns only completed projects with the fields needed for showcase display.

Note: The `completedAt` field must exist and be indexed in Firestore for the orderBy to work. If the index doesn't exist, Firestore will log the index creation URL in the server console. The executor should note this in the SUMMARY for manual index creation if needed. Alternatively, if `completedAt` ordering fails, fall back to `createdAt` ordering with a comment.

2. Create `src/components/projects/ShowcaseCard.tsx`:

Follow the pattern of the existing `ProjectCard.tsx` but adapted for showcase:

```typescript
"use client";

import Link from "next/link";
import Image from "next/image";
import { Project, ProjectDifficulty } from "@/types/mentorship";

interface ShowcaseCardProps {
  project: Project;
}

export default function ShowcaseCard({ project }: ShowcaseCardProps) {
  const difficultyColors: Record<ProjectDifficulty, string> = {
    beginner: "badge-success",
    intermediate: "badge-warning",
    advanced: "badge-error",
  };

  const truncatedDescription =
    project.description.length > 150
      ? project.description.substring(0, 150) + "..."
      : project.description;

  // Format completion date
  const completedDate = project.completedAt
    ? new Date(project.completedAt as unknown as string).toLocaleDateString("en-US", {
        month: "short",
        year: "numeric",
      })
    : null;

  return (
    <div className="card bg-base-200 shadow-md hover:shadow-lg transition-shadow h-full">
      <div className="card-body">
        {/* Header with title and completion badge */}
        <div className="flex items-start justify-between gap-2">
          <Link href={`/projects/${project.id}`} className="flex-1">
            <h2 className="card-title text-lg hover:text-primary transition-colors cursor-pointer">
              {project.title}
            </h2>
          </Link>
          <span className="badge badge-info badge-sm whitespace-nowrap">Completed</span>
        </div>

        {/* Creator */}
        <div className="flex items-center gap-2 mb-1">
          {project.creatorProfile?.photoURL && (
            <Image
              src={project.creatorProfile.photoURL}
              alt={project.creatorProfile.displayName}
              width={20}
              height={20}
              className="rounded-full"
            />
          )}
          <span className="text-sm text-base-content/70">
            {project.creatorProfile?.displayName}
          </span>
          {completedDate && (
            <span className="text-xs text-base-content/50 ml-auto">
              {completedDate}
            </span>
          )}
        </div>

        {/* Description */}
        <p className="text-sm text-base-content/70 mb-2">{truncatedDescription}</p>

        {/* Tech Stack */}
        <div className="flex flex-wrap gap-1 mb-2">
          {project.techStack.slice(0, 4).map((tech, index) => (
            <span key={index} className="badge badge-xs badge-outline">
              {tech}
            </span>
          ))}
          {project.techStack.length > 4 && (
            <span className="badge badge-xs badge-outline">
              +{project.techStack.length - 4}
            </span>
          )}
        </div>

        {/* Difficulty */}
        <div className="flex items-center gap-2 mb-3">
          <span className={`badge badge-xs ${difficultyColors[project.difficulty]}`}>
            {project.difficulty}
          </span>
        </div>

        {/* Action Links */}
        <div className="card-actions justify-end mt-auto">
          {project.demoUrl && (
            <a
              href={project.demoUrl as string}
              target="_blank"
              rel="noopener noreferrer"
              className="btn btn-primary btn-sm"
            >
              View Demo
            </a>
          )}
          <Link href={`/projects/${project.id}`} className="btn btn-ghost btn-sm">
            Details
          </Link>
        </div>
      </div>
    </div>
  );
}
```

Key differences from ProjectCard:
- Shows "Completed" badge instead of status
- Shows completion date
- Has "View Demo" button when demoUrl exists
- Links to project detail page for full information
- Slightly longer description truncation (150 chars vs 120)
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Verify `src/app/api/projects/showcase/route.ts` exists and exports GET. Verify `src/components/projects/ShowcaseCard.tsx` exists and renders demo link conditionally.
  </verify>
  <done>Showcase API endpoint returns completed projects ordered by completedAt. ShowcaseCard component displays project info with demo link, completion date, and tech stack badges. TypeScript compiles.</done>
</task>

<task type="auto">
  <name>Task 2: Create showcase page with filters</name>
  <files>src/components/projects/ShowcaseFilters.tsx, src/app/projects/showcase/page.tsx</files>
  <action>
1. Create `src/components/projects/ShowcaseFilters.tsx`:

Follow the pattern of the existing `ProjectFilters.tsx` but adapted for showcase:

```typescript
"use client";

interface ShowcaseFiltersProps {
  searchTerm: string;
  setSearchTerm: (value: string) => void;
  techFilter: string[];
  setTechFilter: (value: string[]) => void;
  sortOrder: "newest" | "oldest";
  setSortOrder: (value: "newest" | "oldest") => void;
  availableTechs: string[];
}

export default function ShowcaseFilters({
  searchTerm,
  setSearchTerm,
  techFilter,
  setTechFilter,
  sortOrder,
  setSortOrder,
  availableTechs,
}: ShowcaseFiltersProps) {
  const handleTechToggle = (tech: string) => {
    if (techFilter.includes(tech)) {
      setTechFilter(techFilter.filter((t) => t !== tech));
    } else {
      setTechFilter([...techFilter, tech]);
    }
  };

  return (
    <div className="space-y-4 mb-6">
      {/* Search */}
      <div className="form-control">
        <label className="label">
          <span className="label-text font-semibold">Search Showcase</span>
        </label>
        <input
          type="text"
          placeholder="Search by project name or description..."
          className="input input-bordered w-full"
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
        />
      </div>

      {/* Sort by completion date */}
      <div className="form-control">
        <label className="label">
          <span className="label-text font-semibold">Sort by Completion Date</span>
        </label>
        <select
          className="select select-bordered w-full"
          value={sortOrder}
          onChange={(e) => setSortOrder(e.target.value as "newest" | "oldest")}
        >
          <option value="newest">Newest First</option>
          <option value="oldest">Oldest First</option>
        </select>
      </div>

      {/* Tech Stack Filter */}
      {availableTechs.length > 0 && (
        <div className="form-control">
          <label className="label">
            <span className="label-text font-semibold">Tech Stack</span>
          </label>
          <div className="flex flex-wrap gap-2">
            {availableTechs.map((tech) => (
              <button
                key={tech}
                onClick={() => handleTechToggle(tech)}
                className={`badge badge-lg cursor-pointer transition-colors ${
                  techFilter.includes(tech) ? "badge-primary" : "badge-outline"
                }`}
              >
                {tech}
              </button>
            ))}
          </div>
          {techFilter.length > 0 && (
            <button
              onClick={() => setTechFilter([])}
              className="btn btn-ghost btn-sm mt-2"
            >
              Clear Tech Filters
            </button>
          )}
        </div>
      )}
    </div>
  );
}
```

2. Create `src/app/projects/showcase/page.tsx`:

Follow the structure of `src/app/projects/discover/page.tsx` as the pattern:

```typescript
"use client";

import { useState, useEffect, Suspense } from "react";
import ShowcaseCard from "@/components/projects/ShowcaseCard";
import ShowcaseFilters from "@/components/projects/ShowcaseFilters";
import { Project } from "@/types/mentorship";
import Link from "next/link";

export const dynamic = "force-dynamic";

function ShowcaseContent() {
  const [projects, setProjects] = useState<Project[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const [searchTerm, setSearchTerm] = useState("");
  const [techFilter, setTechFilter] = useState<string[]>([]);
  const [sortOrder, setSortOrder] = useState<"newest" | "oldest">("newest");

  useEffect(() => {
    const fetchShowcase = async () => {
      try {
        setLoading(true);
        const response = await fetch("/api/projects/showcase");
        if (!response.ok) throw new Error("Failed to fetch showcase");
        const data = await response.json();
        setProjects(data.projects || []);
        setError(null);
      } catch (err) {
        console.error("Error fetching showcase:", err);
        setError("Failed to load showcase. Please try again later.");
      } finally {
        setLoading(false);
      }
    };

    fetchShowcase();
  }, []);

  // Extract unique tech stacks from all showcase projects
  const availableTechs = Array.from(
    new Set(projects.flatMap((p) => p.techStack))
  ).sort();

  // Client-side filtering and sorting
  const filteredProjects = projects
    .filter((project) => {
      // Search filter
      if (searchTerm) {
        const searchLower = searchTerm.toLowerCase();
        const matchesSearch =
          project.title.toLowerCase().includes(searchLower) ||
          project.description.toLowerCase().includes(searchLower);
        if (!matchesSearch) return false;
      }

      // Tech stack filter (any match)
      if (techFilter.length > 0) {
        const hasMatchingTech = techFilter.some((tech) =>
          project.techStack.includes(tech)
        );
        if (!hasMatchingTech) return false;
      }

      return true;
    })
    .sort((a, b) => {
      // Sort by completion date
      const dateA = a.completedAt ? new Date(a.completedAt as unknown as string).getTime() : 0;
      const dateB = b.completedAt ? new Date(b.completedAt as unknown as string).getTime() : 0;
      return sortOrder === "newest" ? dateB - dateA : dateA - dateB;
    });

  if (loading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <span className="loading loading-spinner loading-lg"></span>
      </div>
    );
  }

  if (error) {
    return (
      <div className="max-w-6xl mx-auto p-8">
        <div className="alert alert-error">
          <svg xmlns="http://www.w3.org/2000/svg" className="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <span>{error}</span>
        </div>
      </div>
    );
  }

  return (
    <div className="max-w-6xl mx-auto p-8">
      <div className="flex items-center justify-between mb-8">
        <div>
          <h1 className="text-3xl font-bold mb-2">Project Showcase</h1>
          <p className="text-base-content/70">
            Explore completed projects and their demos from our community
          </p>
        </div>
        <Link href="/projects/discover" className="btn btn-ghost btn-sm">
          Active Projects
        </Link>
      </div>

      <ShowcaseFilters
        searchTerm={searchTerm}
        setSearchTerm={setSearchTerm}
        techFilter={techFilter}
        setTechFilter={setTechFilter}
        sortOrder={sortOrder}
        setSortOrder={setSortOrder}
        availableTechs={availableTechs}
      />

      {filteredProjects.length === 0 ? (
        <div className="text-center py-12">
          <p className="text-lg text-base-content/70">
            {projects.length === 0
              ? "No completed projects yet. Check back soon!"
              : "No projects match your filters"}
          </p>
          {projects.length === 0 && (
            <Link href="/projects/discover" className="btn btn-primary mt-4">
              Discover Active Projects
            </Link>
          )}
        </div>
      ) : (
        <>
          <div className="mb-4 text-sm text-base-content/70">
            Showing {filteredProjects.length} of {projects.length} completed projects
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {filteredProjects.map((project) => (
              <ShowcaseCard key={project.id} project={project} />
            ))}
          </div>
        </>
      )}
    </div>
  );
}

export default function ShowcasePage() {
  return (
    <Suspense
      fallback={
        <div className="flex justify-center items-center min-h-screen">
          <span className="loading loading-spinner loading-lg"></span>
        </div>
      }
    >
      <ShowcaseContent />
    </Suspense>
  );
}
```

Note: This page does NOT need `MentorshipProvider` since it's public and doesn't check auth. The `src/app/projects/layout.tsx` already wraps all `/projects/*` routes with MentorshipProvider, so it's available if needed but not required for this page.

Key design decisions:
- No URL param syncing for filters (simpler than discover page - showcase is a browse experience, not a search destination)
- Client-side filtering (same pattern as discover page)
- Sort by completion date (newest/oldest) rather than difficulty filter (all completed projects are proven)
- Empty state links to discover page to drive engagement
- "Active Projects" link in header for navigation between discover and showcase
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Run `npm run build` to verify the showcase page builds. Verify the route `/projects/showcase` resolves correctly by checking the page file exists at the expected path.
  </verify>
  <done>Showcase page at /projects/showcase displays completed projects in a grid. ShowcaseFilters provides tech stack filtering and completion date sorting. ShowcaseCard shows project info with "View Demo" button. Page works without authentication. Build succeeds.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds
3. `src/app/api/projects/showcase/route.ts` exists and exports GET
4. `src/app/projects/showcase/page.tsx` exists and renders showcase grid
5. `src/components/projects/ShowcaseCard.tsx` renders demo link when demoUrl exists
6. `src/components/projects/ShowcaseFilters.tsx` has tech filter and sort order
7. Showcase page fetches from `/api/projects/showcase`
8. Client-side filtering works for tech stack and sorting by date
</verification>

<success_criteria>
- DEMO-03: Public showcase page displays completed projects with demos at /projects/showcase
- DEMO-04: Showcase filterable by tech stack (toggle badges) and sortable by completion date (newest/oldest)
</success_criteria>

<output>
After completion, create `.planning/phases/07-projects-demos-templates/07-06-SUMMARY.md`
</output>
