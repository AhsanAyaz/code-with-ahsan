---
phase: 04-foundation-and-permissions
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - firestore.rules
  - src/lib/validation/urls.ts
  - src/lib/validation/sanitize.ts
autonomous: true

must_haves:
  truths:
    - "Firestore security rules enforce role-based access for projects, project_members, roadmaps, and roadmap versions"
    - "GitHub URLs validated against https://github.com pattern before acceptance"
    - "Markdown content sanitized to strip script tags, event handlers, and dangerous elements"
  artifacts:
    - path: "firestore.rules"
      provides: "Firestore security rules for all v2.0 collections"
      contains: "match /projects/"
    - path: "src/lib/validation/urls.ts"
      provides: "GitHub URL validation using zod"
      exports: ["validateGitHubUrl"]
    - path: "src/lib/validation/sanitize.ts"
      provides: "Markdown XSS sanitization using rehype-sanitize"
      exports: ["sanitizeMarkdown"]
  key_links:
    - from: "firestore.rules"
      to: "request.auth.token"
      via: "custom claims check"
      pattern: "request\\.auth\\.token\\.admin"
    - from: "src/lib/validation/urls.ts"
      to: "zod"
      via: "schema validation"
      pattern: "z\\.string"
---

<objective>
Create Firestore security rules for v2.0 collections and input validation utilities for GitHub URLs and Markdown content.

Purpose: Defense-in-depth security. Security rules prevent unauthorized Firestore access even if application code is bypassed. Validation utilities ensure data integrity for GitHub URLs (PERM-06) and prevent XSS in Markdown content (PERM-05).
Output: firestore.rules file, validation utility modules
</objective>

<execution_context>
@/Users/amu1o5/.claude/get-shit-done/workflows/execute-plan.md
@/Users/amu1o5/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-foundation-and-permissions/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Firestore security rules</name>
  <files>firestore.rules</files>
  <action>
    Create `firestore.rules` at project root with rules for these collections:
    - `projects/{projectId}`
    - `project_members/{memberId}`
    - `roadmaps/{roadmapId}`
    - `roadmaps/{roadmapId}/versions/{versionId}`

    Also preserve any existing collections (mentorship_profiles, mentorship_matches, etc.) by using a permissive fallback or checking if rules already exist.

    Rules implementation:

    ```
    rules_version = '2';
    service cloud.firestore {
      match /databases/{database}/documents {

        // Helper functions
        function isSignedIn() {
          return request.auth != null;
        }

        function isAdmin() {
          return isSignedIn() && request.auth.token.admin == true;
        }

        function isAcceptedMentor() {
          return isSignedIn() &&
                 request.auth.token.role == "mentor" &&
                 request.auth.token.status == "accepted";
        }

        function isOwner(userId) {
          return isSignedIn() && request.auth.uid == userId;
        }

        // ─── Projects ───────────────────────────────
        match /projects/{projectId} {
          // Anyone signed in can read approved/active/completed projects
          // Owner and admin can read any status
          allow read: if isSignedIn() && (
            resource.data.status in ["approved", "active", "completed"] ||
            resource.data.creatorId == request.auth.uid ||
            isAdmin()
          );

          // PERM-01: Only accepted mentors can create projects
          // Must set own uid as creator, status must be "pending"
          allow create: if isAcceptedMentor() &&
                           request.resource.data.creatorId == request.auth.uid &&
                           request.resource.data.status == "pending";

          // Owner can update non-status fields
          allow update: if isSignedIn() &&
                           resource.data.creatorId == request.auth.uid &&
                           request.resource.data.status == resource.data.status &&
                           request.resource.data.creatorId == resource.data.creatorId;

          // PERM-03: Only admins can change project status (approve/reject)
          allow update: if isAdmin();

          // Only owner or admin can delete
          allow delete: if isSignedIn() && (
            resource.data.creatorId == request.auth.uid || isAdmin()
          );
        }

        // ─── Project Members ────────────────────────
        match /project_members/{memberId} {
          // Any signed-in user can read members
          allow read: if isSignedIn();

          // PERM-04: Only project creator or admin can manage members
          // Check project ownership via get()
          allow create: if isSignedIn() && (
            isAdmin() ||
            get(/databases/$(database)/documents/projects/$(request.resource.data.projectId)).data.creatorId == request.auth.uid
          );

          allow update, delete: if isSignedIn() && (
            isAdmin() ||
            get(/databases/$(database)/documents/projects/$(resource.data.projectId)).data.creatorId == request.auth.uid
          );
        }

        // ─── Roadmaps ──────────────────────────────
        match /roadmaps/{roadmapId} {
          // Signed-in users can read approved roadmaps; creator and admin can read any
          allow read: if isSignedIn() && (
            resource.data.status in ["approved", "active"] ||
            resource.data.creatorId == request.auth.uid ||
            isAdmin()
          );

          // PERM-02: Only accepted mentors can create roadmaps
          allow create: if isAcceptedMentor() &&
                           request.resource.data.creatorId == request.auth.uid &&
                           request.resource.data.status == "draft";

          // Creator can update non-status fields on draft/pending roadmaps
          allow update: if isSignedIn() &&
                           resource.data.creatorId == request.auth.uid &&
                           request.resource.data.status == resource.data.status &&
                           resource.data.status in ["draft", "pending"];

          // PERM-03: Only admins can change roadmap status
          allow update: if isAdmin();

          // Only creator or admin can delete
          allow delete: if isSignedIn() && (
            resource.data.creatorId == request.auth.uid || isAdmin()
          );

          // ─── Roadmap Versions (subcollection) ─────
          match /versions/{versionId} {
            // Anyone who can read the roadmap can read versions
            allow read: if isSignedIn();

            // Only roadmap creator can add versions
            allow create: if isSignedIn() &&
                             request.resource.data.createdBy == request.auth.uid;

            // Versions are immutable (audit trail)
            allow update, delete: if false;
          }
        }

        // ─── Existing collections (passthrough) ─────
        // Existing mentorship collections use Admin SDK (server-side),
        // so client-side rules can be restrictive.
        // If existing rules are needed, they should be added here.
        // For now, deny client access to mentorship collections
        // (all mentorship operations go through API routes using Admin SDK).
      }
    }
    ```

    IMPORTANT: This project currently has NO firestore.rules file. The Admin SDK bypasses security rules (server-side). These rules protect against direct client-side Firestore access for the new v2.0 collections. Existing mentorship features use Admin SDK exclusively and are unaffected.
  </action>
  <verify>
    1. File exists at project root: `ls firestore.rules`
    2. File parses correctly: syntax check via `cat firestore.rules | head -5` shows `rules_version = '2';`
    3. Rules cover all 4 collection paths (projects, project_members, roadmaps, roadmaps/versions)
  </verify>
  <done>Firestore security rules file created covering PERM-01, PERM-02, PERM-03, PERM-04 with helper functions for auth checks.</done>
</task>

<task type="auto">
  <name>Task 2: Create input validation utilities</name>
  <files>src/lib/validation/urls.ts, src/lib/validation/sanitize.ts</files>
  <action>
    Create directory `src/lib/validation/` and two modules:

    **src/lib/validation/urls.ts** (PERM-06: GitHub URL validation):
    ```typescript
    import { z } from "zod";

    // Matches: https://github.com/owner/repo or https://github.com/owner/repo/
    // Does NOT match: http://, github.com without https, or non-github URLs
    const githubRepoSchema = z
      .string()
      .url("Must be a valid URL")
      .regex(
        /^https:\/\/github\.com\/[\w.-]+\/[\w.-]+\/?$/,
        "Must be a valid GitHub repository URL (https://github.com/owner/repo)"
      );

    /**
     * Validates a GitHub repository URL.
     * @param url - The URL to validate (optional field - undefined/empty skips validation)
     * @returns The validated URL string
     * @throws ZodError if URL is invalid
     */
    export function validateGitHubUrl(url?: string): string | undefined {
      if (!url || url.trim() === "") return undefined;
      return githubRepoSchema.parse(url.trim());
    }

    /**
     * Check if a string is a valid GitHub repo URL without throwing.
     * @returns true if valid, false otherwise
     */
    export function isValidGitHubUrl(url: string): boolean {
      return githubRepoSchema.safeParse(url).success;
    }
    ```

    **src/lib/validation/sanitize.ts** (PERM-05: Markdown XSS prevention):
    ```typescript
    import rehypeSanitize, { defaultSchema } from "rehype-sanitize";
    import rehypeStringify from "rehype-stringify";
    import remarkParse from "remark-parse";
    import remarkRehype from "remark-rehype";
    import { unified } from "unified";

    // Custom schema: default GitHub-style sanitization with extra restrictions
    const sanitizeSchema = {
      ...defaultSchema,
      tagNames: (defaultSchema.tagNames || []).filter(
        (tag) =>
          !["script", "style", "object", "embed", "applet", "link", "meta", "base", "svg", "math"].includes(tag)
      ),
      attributes: {
        ...defaultSchema.attributes,
        // Strip all event handler attributes from every element
        "*": (defaultSchema.attributes?.["*"] || []).filter(
          (attr) => typeof attr === "string" ? !attr.startsWith("on") : true
        ),
      },
    };

    /**
     * Sanitizes Markdown content to prevent XSS attacks.
     * Converts Markdown to HTML, strips dangerous elements, returns sanitized HTML.
     *
     * @param markdown - Raw Markdown string
     * @returns Sanitized HTML string
     */
    export async function sanitizeMarkdown(markdown: string): Promise<string> {
      const file = await unified()
        .use(remarkParse)
        .use(remarkRehype, { allowDangerousHtml: false })
        .use(rehypeSanitize, sanitizeSchema)
        .use(rehypeStringify)
        .process(markdown);

      return String(file);
    }

    /**
     * Sanitizes raw Markdown by stripping potentially dangerous patterns
     * without converting to HTML. Useful for storing sanitized Markdown.
     *
     * Strips: script tags, javascript: URLs, data: URLs in links, event handlers
     *
     * @param markdown - Raw Markdown string
     * @returns Cleaned Markdown string
     */
    export function sanitizeMarkdownRaw(markdown: string): string {
      return markdown
        // Remove script tags and contents
        .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, "")
        // Remove event handlers in any HTML
        .replace(/\s+on\w+\s*=\s*["'][^"']*["']/gi, "")
        // Remove javascript: URLs
        .replace(/javascript\s*:/gi, "")
        // Remove data: URLs in markdown links (potential XSS vector)
        .replace(/\[([^\]]*)\]\(data:[^)]+\)/gi, "[$1](removed)")
        // Remove vbscript: URLs
        .replace(/vbscript\s*:/gi, "");
    }
    ```

    Note: `rehype-sanitize` and `rehype-stringify` may already be available as transitive deps from the existing remark/rehype ecosystem. If `rehype-stringify` is not installed, add it: `npm install rehype-stringify`. Check `remark-parse` and `remark-rehype` similarly -- they may need to be installed as direct deps if not already. The existing project uses `react-markdown` which depends on some of these, but for server-side unified pipeline we need them as direct deps.

    Run `npm install unified remark-parse remark-rehype rehype-stringify` if any are missing (check package.json first).
  </action>
  <verify>
    1. Files exist: `ls src/lib/validation/urls.ts src/lib/validation/sanitize.ts`
    2. TypeScript compiles: `npx tsc --noEmit`
    3. Quick smoke test in Node (optional): create a temp test file that imports and calls validateGitHubUrl
  </verify>
  <done>
    - validateGitHubUrl validates GitHub repo URLs using zod schema
    - isValidGitHubUrl provides boolean check without throwing
    - sanitizeMarkdown converts Markdown to sanitized HTML (for rendering)
    - sanitizeMarkdownRaw strips dangerous patterns from raw Markdown (for storage)
    - Both modules are importable from @/lib/validation/
  </done>
</task>

</tasks>

<verification>
1. `firestore.rules` exists at project root with rules for projects, project_members, roadmaps, roadmaps/versions
2. `src/lib/validation/urls.ts` exports validateGitHubUrl and isValidGitHubUrl
3. `src/lib/validation/sanitize.ts` exports sanitizeMarkdown and sanitizeMarkdownRaw
4. `npx tsc --noEmit` passes
5. Security rules enforce: PERM-01 (mentor creates projects), PERM-02 (mentor creates roadmaps), PERM-03 (admin approves), PERM-04 (owner/admin manages members)
</verification>

<success_criteria>
- Firestore security rules file created with role-based access control
- GitHub URL validation rejects non-GitHub URLs and accepts valid ones
- Markdown sanitization strips script tags and event handlers
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/04-foundation-and-permissions/04-02-SUMMARY.md`
</output>
