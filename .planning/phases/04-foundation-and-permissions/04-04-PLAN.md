---
phase: 04-foundation-and-permissions
plan: 04
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - src/__tests__/security-rules/firestore.test.ts
  - src/__tests__/validation/urls.test.ts
  - src/__tests__/validation/sanitize.test.ts
autonomous: true

must_haves:
  truths:
    - "Security rules tests validate that accepted mentors can create projects and non-mentors cannot"
    - "Security rules tests validate that only admins can change project/roadmap status"
    - "Security rules tests validate that project creator cannot be bypassed by other users"
    - "URL validation tests confirm valid GitHub URLs pass and invalid ones reject"
    - "Sanitization tests confirm script tags and event handlers are stripped"
  artifacts:
    - path: "src/__tests__/security-rules/firestore.test.ts"
      provides: "Firebase security rules integration tests"
      contains: "assertSucceeds"
    - path: "src/__tests__/validation/urls.test.ts"
      provides: "GitHub URL validation unit tests"
      contains: "validateGitHubUrl"
    - path: "src/__tests__/validation/sanitize.test.ts"
      provides: "Markdown sanitization unit tests"
      contains: "sanitizeMarkdown"
  key_links:
    - from: "src/__tests__/security-rules/firestore.test.ts"
      to: "firestore.rules"
      via: "reads rules file and loads into emulator"
      pattern: "readFileSync.*firestore\\.rules"
    - from: "src/__tests__/validation/urls.test.ts"
      to: "src/lib/validation/urls.ts"
      via: "imports validation functions"
      pattern: "from.*@/lib/validation/urls"
---

<objective>
Write tests for Firestore security rules (using Firebase emulator) and validation utilities (URL validation, Markdown sanitization).

Purpose: Security rules tests verify defense-in-depth by testing all role/action combinations against the Firebase emulator. Validation tests ensure GitHub URLs are properly validated (PERM-06) and Markdown XSS prevention works (PERM-05). Together these cover the remaining untested Phase 4 deliverables.
Output: Test files covering security rules and validation utilities
</objective>

<execution_context>
@/Users/amu1o5/.claude/get-shit-done/workflows/execute-plan.md
@/Users/amu1o5/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-foundation-and-permissions/04-RESEARCH.md
@.planning/phases/04-foundation-and-permissions/04-01-SUMMARY.md
@.planning/phases/04-foundation-and-permissions/04-02-SUMMARY.md
@firestore.rules
@src/lib/validation/urls.ts
@src/lib/validation/sanitize.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validation utility tests</name>
  <files>src/__tests__/validation/urls.test.ts, src/__tests__/validation/sanitize.test.ts</files>
  <action>
    Create `src/__tests__/validation/` directory and two test files.

    **src/__tests__/validation/urls.test.ts:**
    ```typescript
    import { describe, it, expect } from "vitest";
    import { validateGitHubUrl, isValidGitHubUrl } from "@/lib/validation/urls";

    describe("validateGitHubUrl", () => {
      // Valid URLs
      it("accepts standard GitHub repo URL", () => {
        expect(validateGitHubUrl("https://github.com/owner/repo")).toBe("https://github.com/owner/repo");
      });

      it("accepts GitHub repo URL with trailing slash", () => {
        expect(validateGitHubUrl("https://github.com/owner/repo/")).toBe("https://github.com/owner/repo/");
      });

      it("accepts URL with dots and hyphens in names", () => {
        expect(validateGitHubUrl("https://github.com/my-org/my.repo-name")).toBeDefined();
      });

      it("returns undefined for empty string", () => {
        expect(validateGitHubUrl("")).toBeUndefined();
      });

      it("returns undefined for undefined", () => {
        expect(validateGitHubUrl(undefined)).toBeUndefined();
      });

      // Invalid URLs
      it("rejects HTTP (non-HTTPS) GitHub URL", () => {
        expect(() => validateGitHubUrl("http://github.com/owner/repo")).toThrow();
      });

      it("rejects non-GitHub URL", () => {
        expect(() => validateGitHubUrl("https://gitlab.com/owner/repo")).toThrow();
      });

      it("rejects GitHub URL without repo name", () => {
        expect(() => validateGitHubUrl("https://github.com/owner")).toThrow();
      });

      it("rejects GitHub URL with extra path segments", () => {
        expect(() => validateGitHubUrl("https://github.com/owner/repo/tree/main")).toThrow();
      });

      it("rejects random string", () => {
        expect(() => validateGitHubUrl("not-a-url")).toThrow();
      });

      it("rejects javascript: URL", () => {
        expect(() => validateGitHubUrl("javascript:alert(1)")).toThrow();
      });
    });

    describe("isValidGitHubUrl", () => {
      it("returns true for valid GitHub URL", () => {
        expect(isValidGitHubUrl("https://github.com/owner/repo")).toBe(true);
      });

      it("returns false for invalid URL", () => {
        expect(isValidGitHubUrl("https://gitlab.com/owner/repo")).toBe(false);
      });
    });
    ```

    **src/__tests__/validation/sanitize.test.ts:**
    ```typescript
    import { describe, it, expect } from "vitest";
    import { sanitizeMarkdown, sanitizeMarkdownRaw } from "@/lib/validation/sanitize";

    describe("sanitizeMarkdown", () => {
      it("preserves normal markdown content", async () => {
        const input = "# Hello World\n\nThis is a paragraph.";
        const result = await sanitizeMarkdown(input);
        expect(result).toContain("Hello World");
        expect(result).toContain("paragraph");
      });

      it("preserves code blocks", async () => {
        const input = "```javascript\nconsole.log('hello');\n```";
        const result = await sanitizeMarkdown(input);
        expect(result).toContain("console.log");
      });

      it("preserves links", async () => {
        const input = "[Click here](https://example.com)";
        const result = await sanitizeMarkdown(input);
        expect(result).toContain("https://example.com");
      });

      it("strips script tags", async () => {
        const input = "Normal text <script>alert('xss')</script> more text";
        const result = await sanitizeMarkdown(input);
        expect(result).not.toContain("<script");
        expect(result).not.toContain("alert");
        expect(result).toContain("Normal text");
      });

      it("strips event handler attributes", async () => {
        const input = '<div onmouseover="alert(1)">hover me</div>';
        const result = await sanitizeMarkdown(input);
        expect(result).not.toContain("onmouseover");
        expect(result).not.toContain("alert");
      });

      it("strips style tags", async () => {
        const input = "<style>body { display: none; }</style>Content";
        const result = await sanitizeMarkdown(input);
        expect(result).not.toContain("<style");
      });

      it("handles empty input", async () => {
        const result = await sanitizeMarkdown("");
        expect(result).toBe("");
      });
    });

    describe("sanitizeMarkdownRaw", () => {
      it("strips script tags from raw markdown", () => {
        const input = "Hello <script>alert('xss')</script> world";
        const result = sanitizeMarkdownRaw(input);
        expect(result).not.toContain("<script");
        expect(result).toContain("Hello");
        expect(result).toContain("world");
      });

      it("strips javascript: URLs", () => {
        const input = "[click](javascript:alert(1))";
        const result = sanitizeMarkdownRaw(input);
        expect(result).not.toContain("javascript:");
      });

      it("strips data: URLs in markdown links", () => {
        const input = "[click](data:text/html,<script>alert(1)</script>)";
        const result = sanitizeMarkdownRaw(input);
        expect(result).toContain("removed");
        expect(result).not.toContain("data:");
      });

      it("strips event handlers from inline HTML", () => {
        const input = '<img src="x" onerror="alert(1)">';
        const result = sanitizeMarkdownRaw(input);
        expect(result).not.toContain("onerror");
      });

      it("preserves normal markdown", () => {
        const input = "# Title\n\n- List item\n- Another item";
        const result = sanitizeMarkdownRaw(input);
        expect(result).toBe(input);
      });
    });
    ```

    Run tests: `npx vitest run src/__tests__/validation/`
  </action>
  <verify>
    `npx vitest run src/__tests__/validation/` passes with all tests green.
  </verify>
  <done>URL validation tests cover valid/invalid GitHub URLs including edge cases. Markdown sanitization tests verify XSS prevention for script tags, event handlers, style tags, and dangerous URL schemes.</done>
</task>

<task type="auto">
  <name>Task 2: Create Firestore security rules tests</name>
  <files>src/__tests__/security-rules/firestore.test.ts</files>
  <action>
    Create `src/__tests__/security-rules/firestore.test.ts` with Firebase emulator-based tests.

    IMPORTANT: These tests require the Firebase emulator running. The test file should:
    1. Use `@firebase/rules-unit-testing` to initialize a test environment
    2. Load `firestore.rules` from project root
    3. Test all role/action combinations for projects, project_members, and roadmaps

    ```typescript
    import { describe, it, beforeAll, afterAll, beforeEach } from "vitest";
    import {
      initializeTestEnvironment,
      assertSucceeds,
      assertFails,
      RulesTestEnvironment,
    } from "@firebase/rules-unit-testing";
    import * as fs from "fs";
    import * as path from "path";

    let testEnv: RulesTestEnvironment;

    beforeAll(async () => {
      testEnv = await initializeTestEnvironment({
        projectId: "test-project-" + Date.now(),
        firestore: {
          rules: fs.readFileSync(
            path.resolve(__dirname, "../../../firestore.rules"),
            "utf8"
          ),
        },
      });
    });

    afterAll(async () => {
      await testEnv.cleanup();
    });

    beforeEach(async () => {
      await testEnv.clearFirestore();
    });

    // Helper: get authenticated context with custom claims
    function asAcceptedMentor(uid = "mentor1") {
      return testEnv.authenticatedContext(uid, {
        role: "mentor",
        status: "accepted",
      });
    }

    function asPendingMentor(uid = "pending-mentor") {
      return testEnv.authenticatedContext(uid, {
        role: "mentor",
        status: "pending",
      });
    }

    function asMentee(uid = "mentee1") {
      return testEnv.authenticatedContext(uid, {
        role: "mentee",
        status: "accepted",
      });
    }

    function asAdmin(uid = "admin1") {
      return testEnv.authenticatedContext(uid, {
        admin: true,
      });
    }

    function asUnauthenticated() {
      return testEnv.unauthenticatedContext();
    }

    describe("Project Security Rules", () => {
      describe("Create", () => {
        it("PERM-01: allows accepted mentor to create project", async () => {
          const ctx = asAcceptedMentor();
          await assertSucceeds(
            ctx.firestore().collection("projects").add({
              title: "Test Project",
              creatorId: "mentor1",
              status: "pending",
              techStack: ["TypeScript"],
            })
          );
        });

        it("PERM-01: denies pending mentor", async () => {
          const ctx = asPendingMentor();
          await assertFails(
            ctx.firestore().collection("projects").add({
              title: "Test",
              creatorId: "pending-mentor",
              status: "pending",
            })
          );
        });

        it("PERM-01: denies mentee", async () => {
          const ctx = asMentee();
          await assertFails(
            ctx.firestore().collection("projects").add({
              title: "Test",
              creatorId: "mentee1",
              status: "pending",
            })
          );
        });

        it("denies unauthenticated user", async () => {
          const ctx = asUnauthenticated();
          await assertFails(
            ctx.firestore().collection("projects").add({
              title: "Test",
              creatorId: "anon",
              status: "pending",
            })
          );
        });

        it("denies mentor from setting creatorId to someone else", async () => {
          const ctx = asAcceptedMentor("mentor1");
          await assertFails(
            ctx.firestore().collection("projects").add({
              title: "Test",
              creatorId: "someone-else",
              status: "pending",
            })
          );
        });

        it("denies mentor from creating project with approved status", async () => {
          const ctx = asAcceptedMentor();
          await assertFails(
            ctx.firestore().collection("projects").add({
              title: "Test",
              creatorId: "mentor1",
              status: "approved",
            })
          );
        });
      });

      describe("Update (status changes)", () => {
        it("PERM-03: allows admin to change project status", async () => {
          // Setup: create project via admin (bypass rules)
          await testEnv.withSecurityRulesDisabled(async (context) => {
            await context.firestore().collection("projects").doc("proj1").set({
              title: "Test",
              creatorId: "mentor1",
              status: "pending",
            });
          });

          const admin = asAdmin();
          await assertSucceeds(
            admin.firestore().collection("projects").doc("proj1").update({
              status: "approved",
              approvedBy: "admin1",
            })
          );
        });

        it("PERM-03: denies non-admin from changing status", async () => {
          await testEnv.withSecurityRulesDisabled(async (context) => {
            await context.firestore().collection("projects").doc("proj2").set({
              title: "Test",
              creatorId: "mentor1",
              status: "pending",
            });
          });

          const mentor = asAcceptedMentor("mentor1");
          await assertFails(
            mentor.firestore().collection("projects").doc("proj2").update({
              status: "approved",
            })
          );
        });
      });

      describe("Update (non-status)", () => {
        it("allows owner to update non-status fields", async () => {
          await testEnv.withSecurityRulesDisabled(async (context) => {
            await context.firestore().collection("projects").doc("proj3").set({
              title: "Old Title",
              creatorId: "mentor1",
              status: "pending",
            });
          });

          const owner = asAcceptedMentor("mentor1");
          await assertSucceeds(
            owner.firestore().collection("projects").doc("proj3").update({
              title: "New Title",
              status: "pending",
              creatorId: "mentor1",
            })
          );
        });

        it("denies non-owner from updating project", async () => {
          await testEnv.withSecurityRulesDisabled(async (context) => {
            await context.firestore().collection("projects").doc("proj4").set({
              title: "Test",
              creatorId: "mentor1",
              status: "pending",
            });
          });

          const other = asAcceptedMentor("other-mentor");
          await assertFails(
            other.firestore().collection("projects").doc("proj4").update({
              title: "Hacked Title",
              status: "pending",
              creatorId: "mentor1",
            })
          );
        });
      });
    });

    describe("Roadmap Security Rules", () => {
      it("PERM-02: allows accepted mentor to create roadmap", async () => {
        const ctx = asAcceptedMentor();
        await assertSucceeds(
          ctx.firestore().collection("roadmaps").add({
            title: "Web Dev Roadmap",
            creatorId: "mentor1",
            status: "draft",
            version: 1,
          })
        );
      });

      it("PERM-02: denies mentee from creating roadmap", async () => {
        const ctx = asMentee();
        await assertFails(
          ctx.firestore().collection("roadmaps").add({
            title: "Roadmap",
            creatorId: "mentee1",
            status: "draft",
          })
        );
      });

      it("PERM-03: allows admin to approve roadmap", async () => {
        await testEnv.withSecurityRulesDisabled(async (context) => {
          await context.firestore().collection("roadmaps").doc("road1").set({
            title: "Roadmap",
            creatorId: "mentor1",
            status: "pending",
          });
        });

        const admin = asAdmin();
        await assertSucceeds(
          admin.firestore().collection("roadmaps").doc("road1").update({
            status: "approved",
            approvedBy: "admin1",
          })
        );
      });

      it("denies mentor from approving own roadmap", async () => {
        await testEnv.withSecurityRulesDisabled(async (context) => {
          await context.firestore().collection("roadmaps").doc("road2").set({
            title: "Roadmap",
            creatorId: "mentor1",
            status: "pending",
          });
        });

        const mentor = asAcceptedMentor("mentor1");
        await assertFails(
          mentor.firestore().collection("roadmaps").doc("road2").update({
            status: "approved",
          })
        );
      });
    });

    describe("Roadmap Versions", () => {
      it("allows creator to add version", async () => {
        await testEnv.withSecurityRulesDisabled(async (context) => {
          await context.firestore().collection("roadmaps").doc("road3").set({
            title: "Roadmap",
            creatorId: "mentor1",
            status: "draft",
          });
        });

        const mentor = asAcceptedMentor("mentor1");
        await assertSucceeds(
          mentor.firestore()
            .collection("roadmaps").doc("road3")
            .collection("versions").add({
              version: 1,
              content: "# Version 1",
              createdBy: "mentor1",
            })
        );
      });

      it("denies version deletion (immutable)", async () => {
        await testEnv.withSecurityRulesDisabled(async (context) => {
          await context.firestore().collection("roadmaps").doc("road4").set({
            title: "Roadmap",
            creatorId: "mentor1",
          });
          await context.firestore()
            .collection("roadmaps").doc("road4")
            .collection("versions").doc("v1").set({
              version: 1,
              content: "Content",
              createdBy: "mentor1",
            });
        });

        const mentor = asAcceptedMentor("mentor1");
        await assertFails(
          mentor.firestore()
            .collection("roadmaps").doc("road4")
            .collection("versions").doc("v1").delete()
        );
      });

      it("denies version update (immutable)", async () => {
        await testEnv.withSecurityRulesDisabled(async (context) => {
          await context.firestore().collection("roadmaps").doc("road5").set({
            title: "Roadmap",
            creatorId: "mentor1",
          });
          await context.firestore()
            .collection("roadmaps").doc("road5")
            .collection("versions").doc("v1").set({
              version: 1,
              content: "Content",
              createdBy: "mentor1",
            });
        });

        const mentor = asAcceptedMentor("mentor1");
        await assertFails(
          mentor.firestore()
            .collection("roadmaps").doc("road5")
            .collection("versions").doc("v1").update({
              content: "Modified",
            })
        );
      });
    });

    describe("Project Members Security Rules", () => {
      it("PERM-04: allows project owner to add member", async () => {
        await testEnv.withSecurityRulesDisabled(async (context) => {
          await context.firestore().collection("projects").doc("proj-team").set({
            title: "Team Project",
            creatorId: "mentor1",
            status: "active",
          });
        });

        const owner = asAcceptedMentor("mentor1");
        await assertSucceeds(
          owner.firestore().collection("project_members").add({
            projectId: "proj-team",
            userId: "mentee1",
            role: "member",
          })
        );
      });

      it("PERM-04: allows admin to add member", async () => {
        await testEnv.withSecurityRulesDisabled(async (context) => {
          await context.firestore().collection("projects").doc("proj-team2").set({
            title: "Team Project",
            creatorId: "mentor1",
            status: "active",
          });
        });

        const admin = asAdmin();
        await assertSucceeds(
          admin.firestore().collection("project_members").add({
            projectId: "proj-team2",
            userId: "mentee1",
            role: "member",
          })
        );
      });

      it("PERM-04: denies non-owner non-admin from adding member", async () => {
        await testEnv.withSecurityRulesDisabled(async (context) => {
          await context.firestore().collection("projects").doc("proj-team3").set({
            title: "Team Project",
            creatorId: "mentor1",
            status: "active",
          });
        });

        const other = asMentee("mentee-other");
        await assertFails(
          other.firestore().collection("project_members").add({
            projectId: "proj-team3",
            userId: "mentee1",
            role: "member",
          })
        );
      });
    });
    ```

    NOTE: Security rules tests require the Firebase Firestore emulator. If the emulator is not available, these tests should be skipped gracefully. Add a check at the top of the file:

    Before `initializeTestEnvironment`, check if the emulator is reachable. If not, use `describe.skip` for all tests and log a message: "Skipping security rules tests: Firebase emulator not running. Start with: firebase emulators:start --only firestore"

    To run these tests:
    1. Start emulator: `npx firebase emulators:start --only firestore` (in separate terminal)
    2. Run tests: `npx vitest run src/__tests__/security-rules/`

    Add a script to package.json: `"test:rules": "firebase emulators:exec --only firestore 'npx vitest run src/__tests__/security-rules/'"`

    If firebase CLI is not installed globally, note it in the test file comments but do NOT install it as a project dependency. The emulator tests are optional -- core permission logic is tested in Plan 03.
  </action>
  <verify>
    1. `npx vitest run src/__tests__/validation/` passes (validation tests work without emulator)
    2. If Firebase emulator is available: `npx vitest run src/__tests__/security-rules/` passes
    3. If emulator unavailable: tests skip gracefully with informative message
    4. `npx tsc --noEmit` passes
  </verify>
  <done>
    - Validation tests cover 15+ cases for URL validation and Markdown sanitization
    - Security rules tests cover all PERM requirements with role-based assertions
    - Tests gracefully handle missing Firebase emulator
    - All non-emulator tests pass
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run src/__tests__/validation/` all tests pass
2. Security rules tests exist and cover PERM-01 through PERM-04
3. `npx tsc --noEmit` passes
4. Test coverage: URL validation (12+ tests), sanitization (12+ tests), security rules (15+ tests)
</verification>

<success_criteria>
- Validation utility tests pass confirming PERM-05 (XSS) and PERM-06 (URL validation)
- Security rules tests validate PERM-01, PERM-02, PERM-03, PERM-04
- Combined with Plan 03 permission tests: all PERM requirements have test coverage
- Firebase emulator absence does not break test suite
</success_criteria>

<output>
After completion, create `.planning/phases/04-foundation-and-permissions/04-04-SUMMARY.md`
</output>
