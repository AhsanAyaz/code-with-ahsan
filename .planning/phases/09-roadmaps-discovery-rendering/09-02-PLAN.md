---
phase: 09-roadmaps-discovery-rendering
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/roadmaps/MarkdownRenderer.tsx
  - src/app/roadmaps/[id]/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can view roadmap detail page with full Markdown content"
    - "Markdown content renders with syntax highlighting for code blocks"
    - "Roadmap shows author attribution with profile information"
    - "Roadmap displays last updated timestamp and version number"
    - "User can see related mentors who teach the roadmap's domain"
    - "Related mentors section shows top 3 mentors matching domain expertise"
  artifacts:
    - path: "src/components/roadmaps/MarkdownRenderer.tsx"
      provides: "Markdown to HTML renderer with syntax highlighting"
      min_lines: 30
    - path: "src/app/roadmaps/[id]/page.tsx"
      provides: "Server Component roadmap detail page"
      min_lines: 150
  key_links:
    - from: "src/app/roadmaps/[id]/page.tsx"
      to: "/api/roadmaps/[id]"
      via: "Server-side fetch"
      pattern: "fetch.*api/roadmaps/.*id"
    - from: "src/app/roadmaps/[id]/page.tsx"
      to: "/api/mentorship/mentors"
      via: "Server-side fetch for related mentors"
      pattern: "fetch.*api/mentorship/mentors.*public=true"
    - from: "src/components/roadmaps/MarkdownRenderer.tsx"
      to: "react-markdown"
      via: "ReactMarkdown component import"
      pattern: "import.*ReactMarkdown.*react-markdown"
---

<objective>
Create roadmap detail page with Markdown rendering, author attribution, and related mentors

**Purpose:** Display full roadmap content with formatted Markdown, syntax-highlighted code blocks, author profile, and related mentors for user guidance

**Output:**
- `MarkdownRenderer` component using react-markdown + rehype-prism-plus
- Server Component roadmap detail page at `/roadmaps/[id]`
- Related mentors section showing domain-matched mentors
</objective>

<execution_context>
@/Users/amu1o5/.claude/get-shit-done/workflows/execute-plan.md
@/Users/amu1o5/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-roadmaps-discovery-rendering/09-RESEARCH.md
@.planning/phases/08-roadmaps-creation-admin/08-01-SUMMARY.md
@src/types/mentorship.ts
@src/components/mentorship/MentorCard.tsx
@src/app/books/mastering-angular-signals/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Create MarkdownRenderer component</name>
  <files>
src/components/roadmaps/MarkdownRenderer.tsx
  </files>
  <action>
Create reusable Markdown renderer component using react-markdown with syntax highlighting:

**MarkdownRenderer.tsx:**
```typescript
"use client";

import ReactMarkdown from "react-markdown";
import rehypePrism from "rehype-prism-plus";
import remarkGfm from "remark-gfm";

interface MarkdownRendererProps {
  content: string;
}

export default function MarkdownRenderer({ content }: MarkdownRendererProps) {
  return (
    <div className="prose dark:prose-invert max-w-none">
      <ReactMarkdown
        remarkPlugins={[remarkGfm]}
        rehypePlugins={[rehypePrism]}
      >
        {content}
      </ReactMarkdown>
    </div>
  );
}
```

**Why this structure:**
- "use client" directive because react-markdown requires client-side rendering
- remarkGfm plugin enables GitHub Flavored Markdown (tables, strikethrough, task lists)
- rehypePrism plugin adds syntax highlighting using existing Prism CSS from src/css/prism.css
- prose class from @tailwindcss/typography styles rendered HTML
- dark:prose-invert for dark mode support
- max-w-none removes prose width constraint for full-width content

**Dependencies (already installed per research):**
- react-markdown: ^10.1.0
- rehype-prism-plus: ^2.0.1
- remark-gfm: ^4.0.1
- Prism CSS already imported in src/app/globals.css line 105

**Do NOT:**
- Add custom code block components (rehype-prism handles it)
- Add sanitization (API already sanitizes via sanitizeMarkdownRaw)
- Import Prism CSS (already globally imported)
  </action>
  <verify>
npx tsc --noEmit confirms no TypeScript errors
Component exports valid React functional component
Imports from react-markdown, rehype-prism-plus, remark-gfm resolve correctly
  </verify>
  <done>
MarkdownRenderer.tsx exists and exports functional component
Component accepts content prop and renders with ReactMarkdown
remarkGfm and rehypePrism plugins configured
prose classes applied for typography styling
  </done>
</task>

<task type="auto">
  <name>Create roadmap detail page with related mentors</name>
  <files>
src/app/roadmaps/[id]/page.tsx
  </files>
  <action>
Create Server Component roadmap detail page (NO "use client" directive):

**Page structure:**
```typescript
import { notFound } from "next/navigation";
import Image from "next/image";
import MarkdownRenderer from "@/components/roadmaps/MarkdownRenderer";
import MentorCard from "@/components/mentorship/MentorCard";
import { Roadmap, MentorshipProfile } from "@/types/mentorship";

interface RoadmapDetailPageProps {
  params: Promise<{ id: string }>;
}

export default async function RoadmapDetailPage({ params }: RoadmapDetailPageProps) {
  const { id } = await params;

  // Fetch roadmap with full content (Server Component - no loading state)
  const roadmapRes = await fetch(
    `${process.env.NEXT_PUBLIC_BASE_URL}/api/roadmaps/${id}`,
    { cache: "no-store" }
  );

  if (!roadmapRes.ok) {
    notFound();
  }

  const { roadmap } = await roadmapRes.json();

  // Fetch all public mentors
  const mentorsRes = await fetch(
    `${process.env.NEXT_PUBLIC_BASE_URL}/api/mentorship/mentors?public=true`,
    { cache: "no-store" }
  );
  const { mentors } = await mentorsRes.json();

  // Filter related mentors by domain match (fuzzy case-insensitive)
  // Map domain value to readable label for matching
  const domainLabels: Record<string, string> = {
    "web-dev": "Web Development",
    frontend: "Frontend",
    backend: "Backend",
    ml: "Machine Learning",
    ai: "AI",
    mcp: "MCP Servers",
    agents: "AI Agents",
    "prompt-engineering": "Prompt Engineering",
  };

  const domainLabel = domainLabels[roadmap.domain] || roadmap.domain;

  const relatedMentors = mentors
    .filter((mentor: MentorshipProfile) =>
      mentor.expertise?.some(
        (exp: string) =>
          exp.toLowerCase().includes(roadmap.domain.toLowerCase()) ||
          exp.toLowerCase().includes(domainLabel.toLowerCase())
      )
    )
    .slice(0, 3); // Top 3 only

  return (
    <div className="max-w-4xl mx-auto p-8">
      {/* Header Section */}
      <div className="mb-8">
        <h1 className="text-4xl font-bold mb-4">{roadmap.title}</h1>

        {/* Metadata badges */}
        <div className="flex items-center gap-4 text-sm text-base-content/70 mb-4">
          <span className="badge badge-primary">{domainLabel}</span>
          <span className="badge badge-secondary">{roadmap.difficulty}</span>
          {roadmap.estimatedHours && (
            <span>{roadmap.estimatedHours}h estimated</span>
          )}
          <span>Version {roadmap.version}</span>
        </div>

        {/* Author Attribution */}
        {roadmap.creatorProfile && (
          <div className="flex items-center gap-3 mb-4">
            {roadmap.creatorProfile.photoURL && (
              <Image
                src={roadmap.creatorProfile.photoURL}
                alt={roadmap.creatorProfile.displayName}
                width={40}
                height={40}
                className="rounded-full"
              />
            )}
            <div>
              <p className="text-sm text-base-content/70">Created by</p>
              <p className="font-semibold">
                {roadmap.creatorProfile.displayName}
              </p>
            </div>
          </div>
        )}

        {/* Description */}
        {roadmap.description && (
          <p className="text-lg text-base-content/80 mb-4">
            {roadmap.description}
          </p>
        )}

        {/* Last updated timestamp */}
        <p className="text-xs text-base-content/60">
          Last updated: {new Date(roadmap.updatedAt).toLocaleDateString()}
        </p>
      </div>

      {/* Markdown Content */}
      <div className="mb-12">
        <MarkdownRenderer content={roadmap.content} />
      </div>

      {/* Related Mentors Section */}
      {relatedMentors.length > 0 && (
        <div className="mt-12 border-t pt-8">
          <h2 className="text-2xl font-bold mb-4">Related Mentors</h2>
          <p className="text-base-content/70 mb-6">
            These mentors teach {domainLabel} and can help guide you through
            this roadmap
          </p>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            {relatedMentors.map((mentor: MentorshipProfile) => (
              <MentorCard key={mentor.uid} mentor={mentor} />
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
```

**Key implementation notes:**
- Server Component (async function, no "use client")
- Use `cache: 'no-store'` for fresh data (research recommendation)
- Fetch roadmap first, then mentors in parallel would be ideal but sequential is fine for initial implementation
- Domain matching uses case-insensitive partial matching (fuzzy approach from research)
- MentorCard component already exists at src/components/mentorship/MentorCard.tsx (reuse it)
- notFound() triggers Next.js 404 page if roadmap doesn't exist
- Timestamp converted with toLocaleDateString() for readable format

**Do NOT:**
- Add "use client" directive (Server Component for SEO)
- Add loading states (Server Components stream automatically)
- Use useEffect or useState (server-side data fetching)
  </action>
  <verify>
npm run build succeeds and /roadmaps/[id] dynamic route appears in output
npx tsc --noEmit shows no type errors
Build output shows route as Server Component (not Client Component)
Page imports MarkdownRenderer and MentorCard correctly
Related mentors filtering logic uses case-insensitive matching
  </verify>
  <done>
/roadmaps/[id]/page.tsx exists and renders roadmap detail page
Page fetches roadmap content from API and displays with MarkdownRenderer
Header shows title, domain badge, difficulty badge, estimated hours, version number
Author attribution displays creator name and photo
Last updated timestamp shown in readable format
Related mentors section displays top 3 mentors matching roadmap domain
MentorCard components render for each related mentor
  </done>
</task>

</tasks>

<verification>
Manual testing:
1. Visit http://localhost:3000/roadmaps/[valid-roadmap-id]
2. Verify Markdown content renders with formatted headings, lists, code blocks
3. Verify code blocks have syntax highlighting (colored tokens)
4. Verify author section shows creator name and photo
5. Verify metadata badges display domain, difficulty, estimated hours, version
6. Verify "Last updated" timestamp displays
7. Verify Related Mentors section shows mentors with matching expertise
8. Click mentor card â†’ navigates to mentor profile

Build verification:
- npm run build completes without errors
- /roadmaps/[id] appears as Server Component in build output
- No TypeScript compilation errors
- Prism CSS syntax highlighting styles apply correctly
</verification>

<success_criteria>
- [x] Roadmap detail page renders Markdown content with syntax highlighting
- [x] Roadmap detail page shows author attribution with profile link
- [x] Roadmap shows last updated timestamp and version number
- [x] Roadmap detail page shows related mentors who teach that domain
- [x] Related mentors filtered by expertise matching roadmap domain
- [x] Code blocks display with Prism CSS syntax highlighting
- [x] Page uses Server Component architecture for SEO benefits
</success_criteria>

<output>
After completion, create `.planning/phases/09-roadmaps-discovery-rendering/09-02-SUMMARY.md`
</output>
