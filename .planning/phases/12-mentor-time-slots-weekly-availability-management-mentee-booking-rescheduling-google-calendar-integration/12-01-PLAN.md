---
phase: 12-mentor-time-slots-weekly-availability-management-mentee-booking-rescheduling-google-calendar-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/mentorship.ts
  - src/lib/availability.ts
  - src/app/api/mentorship/availability/route.ts
autonomous: true

must_haves:
  truths:
    - "Mentor availability types define weekly time ranges per day with timezone"
    - "Availability calculation produces 30-min slots from time ranges excluding overrides and past slots"
    - "Mentor can save weekly availability schedule to their profile via API"
    - "Mentor can add and remove override dates for unavailability via API"
  artifacts:
    - path: "src/types/mentorship.ts"
      provides: "TimeSlotAvailability, TimeRange, UnavailableDate, MentorBooking types"
      contains: "TimeSlotAvailability"
    - path: "src/lib/availability.ts"
      provides: "calculateAvailableSlots function"
      exports: ["calculateAvailableSlots", "generateSlotsFromRange"]
    - path: "src/app/api/mentorship/availability/route.ts"
      provides: "GET and PUT endpoints for mentor availability"
      exports: ["GET", "PUT"]
  key_links:
    - from: "src/lib/availability.ts"
      to: "src/types/mentorship.ts"
      via: "imports TimeSlotAvailability, TimeRange types"
      pattern: "import.*TimeSlotAvailability.*from.*mentorship"
    - from: "src/app/api/mentorship/availability/route.ts"
      to: "src/lib/availability.ts"
      via: "uses availability types for request/response shaping"
      pattern: "import.*from.*availability"
---

<objective>
Define the data model and availability calculation engine for mentor time slots, plus the API for mentors to manage their weekly availability and override dates.

Purpose: Establish the foundation types, slot calculation logic, and availability CRUD that all subsequent plans depend on.
Output: TypeScript types in mentorship.ts, availability calculation library, and availability API route.
</objective>

<execution_context>
@/home/ahsan/.claude/get-shit-done/workflows/execute-plan.md
@/home/ahsan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-mentor-time-slots-weekly-availability-management-mentee-booking-rescheduling-google-calendar-integration/12-RESEARCH.md
@src/types/mentorship.ts
@src/lib/auth.ts
@src/lib/firebaseAdmin.ts
@src/app/api/mentorship/scheduled-sessions/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define time slot types and availability calculation library</name>
  <files>src/types/mentorship.ts, src/lib/availability.ts</files>
  <action>
**In src/types/mentorship.ts**, add these types at the bottom of the file (after the ProjectTemplate section):

```typescript
// --- Phase 12: Mentor Time Slots ---

export interface TimeRange {
  start: string; // "HH:mm" format e.g. "09:00"
  end: string;   // "HH:mm" format e.g. "12:00"
}

export type DayOfWeek = "monday" | "tuesday" | "wednesday" | "thursday" | "friday" | "saturday" | "sunday";

export interface TimeSlotAvailability {
  /** Weekly recurring availability: day -> array of time ranges */
  weekly: Partial<Record<DayOfWeek, TimeRange[]>>;
  /** Mentor's timezone (IANA format, e.g. "America/New_York") */
  timezone: string;
  /** Slot duration in minutes (fixed at 30 for now) */
  slotDurationMinutes: number;
}

export interface UnavailableDate {
  date: string;    // "YYYY-MM-DD" format
  reason?: string; // Optional reason
}

export type BookingStatus = "confirmed" | "cancelled";

export interface MentorBooking {
  id: string;
  mentorId: string;
  menteeId: string;
  mentorProfile?: {
    displayName: string;
    photoURL: string;
    username?: string;
    discordUsername?: string;
  };
  menteeProfile?: {
    displayName: string;
    photoURL: string;
    username?: string;
    discordUsername?: string;
  };
  startTime: Date;   // UTC
  endTime: Date;     // UTC
  timezone: string;  // Mentor's timezone at time of booking
  status: BookingStatus;
  calendarEventId?: string;       // Google Calendar event ID
  calendarSyncStatus?: "pending" | "synced" | "failed" | "not_connected";
  cancelledBy?: string;           // uid of who cancelled
  cancelledAt?: Date;
  cancellationReason?: string;
  createdAt: Date;
  updatedAt: Date;
}

/** A computed available slot for display/booking */
export interface AvailableSlot {
  start: Date;  // UTC
  end: Date;    // UTC
  /** Display time in mentor's timezone, e.g. "09:00 AM" */
  displayTime: string;
}
```

**In src/lib/availability.ts**, create a new file with the following:

1. `generateSlotsFromRange(date: Date, range: TimeRange, timezone: string, slotDurationMinutes: number): AvailableSlot[]` - Takes a date and a time range, generates individual 30-min slots. Use date-fns to parse "HH:mm" strings relative to the given date, respecting the mentor's timezone. Each slot has start/end as UTC Dates and displayTime as the formatted time string in the mentor's timezone.

2. `calculateAvailableSlots(availability: TimeSlotAvailability, unavailableDates: UnavailableDate[], existingBookings: { startTime: Date; endTime: Date }[], date: Date): AvailableSlot[]` - Main function:
   - Get day of week name from date using date-fns `format(date, 'EEEE')` lowercased
   - Check if date is in unavailableDates array (compare YYYY-MM-DD strings) - return [] if unavailable
   - Get the TimeRange[] for that day from availability.weekly
   - For each range, call generateSlotsFromRange
   - Filter out slots where startTime is before `now + 2 hours` (minimum advance booking)
   - Filter out slots where startTime is after `now + 60 days` (maximum future window)
   - Filter out slots that overlap with any existingBookings (a slot overlaps if slot.start < booking.end AND slot.end > booking.start)
   - Return remaining slots sorted by start time

3. `getDaysInRange(startDate: Date, endDate: Date): Date[]` - Helper that returns an array of dates between start and end (inclusive), used by the time-slots API to generate slots across a date range.

Use `date-fns` (already installed v4.1.0) for date manipulation. For timezone formatting, use `Intl.DateTimeFormat` with the timezone option (avoid adding date-fns-tz dependency since Intl handles this natively). When creating Date objects from "HH:mm" strings for a specific date in a specific timezone, construct the date string as `YYYY-MM-DDTHH:mm:00` and use the timezone offset to convert to UTC.

Actually, for simplicity in generating slots: create dates using `new Date(date.toLocaleDateString('en-CA', { timeZone: timezone }) + 'T' + range.start + ':00')` won't work server-side. Instead:
- Use `Intl.DateTimeFormat` to get the date parts in the mentor's timezone
- Construct the local time string, then use a simple offset calculation
- OR use date-fns `parse` with `set` to build the time on the given date, treating it as UTC then adjusting

The simplest correct approach: Build an ISO string like `2026-02-15T09:00:00` and create a Date interpreted in the mentor's timezone. Since Node.js supports `Intl`, get the timezone offset with:
```typescript
function dateInTimezone(dateStr: string, time: string, timezone: string): Date {
  // Create a reference date at midnight UTC for the target date
  const utcDate = new Date(`${dateStr}T${time}:00.000Z`);
  // Get the timezone offset by comparing UTC midnight to midnight-in-timezone
  const formatter = new Intl.DateTimeFormat('en-US', {
    timeZone: timezone,
    year: 'numeric', month: '2-digit', day: '2-digit',
    hour: '2-digit', minute: '2-digit', second: '2-digit',
    hour12: false
  });
  // Use the offset to adjust
  const parts = formatter.formatToParts(utcDate);
  // ... calculate offset and adjust
}
```

A cleaner approach for server-side: install `date-fns-tz` (it's small and purpose-built). BUT to avoid adding a dependency, use this well-known pattern:
```typescript
function toUTCFromTimezone(year: number, month: number, day: number, hours: number, minutes: number, timezone: string): Date {
  // Create a date string and get offset
  const localStr = `${year}-${String(month).padStart(2,'0')}-${String(day).padStart(2,'0')}T${String(hours).padStart(2,'0')}:${String(minutes).padStart(2,'0')}:00`;
  // Trick: use toLocaleString to find offset
  const utcDate = new Date(localStr + 'Z');
  const utcStr = utcDate.toLocaleString('en-US', { timeZone: 'UTC' });
  const tzStr = utcDate.toLocaleString('en-US', { timeZone: timezone });
  const utcTime = new Date(utcStr).getTime();
  const tzTime = new Date(tzStr).getTime();
  const offset = utcTime - tzTime;
  return new Date(new Date(localStr).getTime() + offset);
}
```

Actually, the SIMPLEST correct approach is to just install `date-fns-tz` as it's already in the research recommendations. Run `npm install date-fns-tz` and use `fromZonedTime` (renamed from `zonedTimeToUtc` in v3) to convert timezone-local times to UTC, and `toZonedTime` for the reverse. This is clean, tested, and avoids hand-rolling timezone math.

```typescript
import { fromZonedTime, toZonedTime, format as formatTZ } from "date-fns-tz";
import { format, addMinutes, isBefore, isAfter, isSameDay, parse, addDays, startOfDay } from "date-fns";
```

Export all three functions. Add JSDoc comments.
  </action>
  <verify>
Run `npx tsc --noEmit` and confirm no type errors. Verify the new types in mentorship.ts compile. Verify availability.ts compiles and exports the expected functions.
  </verify>
  <done>
TimeSlotAvailability, TimeRange, UnavailableDate, MentorBooking, AvailableSlot types exist in mentorship.ts. calculateAvailableSlots correctly generates 30-min slots from weekly availability, filters out unavailable dates, past slots (2hr advance), far-future slots (60 days), and conflicting bookings. date-fns-tz installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create availability API route for mentor schedule management</name>
  <files>src/app/api/mentorship/availability/route.ts</files>
  <action>
Create `src/app/api/mentorship/availability/route.ts` with GET and PUT handlers:

**GET /api/mentorship/availability?mentorId={uid}**
- Public endpoint (no auth required) - mentees need to see mentor availability
- Query Firestore `mentorship_profiles/{mentorId}` document
- Return `{ availability: TimeSlotAvailability | null, unavailableDates: UnavailableDate[] }` from the profile
- If mentor has no availability set, return `{ availability: null, unavailableDates: [] }`
- The availability data is stored as `timeSlotAvailability` field on the mentorship_profiles document (to avoid conflict with existing `availability` field which is `Record<string, string[]>`)
- The unavailable dates are stored as `unavailableDates` field on the mentorship_profiles document

**PUT /api/mentorship/availability** (authenticated - mentor only)
- Require auth via `verifyAuth(request)` from `@/lib/auth`
- Body: `{ availability?: TimeSlotAvailability, unavailableDates?: UnavailableDate[] }`
- Verify the authenticated user's uid matches a mentor profile (query `mentorship_profiles` where `uid == auth.uid` and `role == "mentor"`)
- If `availability` provided: validate that weekly keys are valid day names, time ranges have valid HH:mm format (regex `^\d{2}:\d{2}$`), start < end for each range, timezone is a non-empty string
- If `unavailableDates` provided: validate each has a valid YYYY-MM-DD date string
- Update the mentor's profile document with `timeSlotAvailability` and/or `unavailableDates` fields
- Return 200 with `{ success: true }`

Follow the existing API route patterns:
- Import `{ NextRequest, NextResponse }` from "next/server"
- Import `{ db }` from "@/lib/firebaseAdmin"
- Import `{ verifyAuth }` from "@/lib/auth"
- Use try/catch with appropriate error status codes (400, 401, 403, 500)
- Log errors with console.error

Validation helper: create a local `isValidTimeFormat(time: string): boolean` that checks `^\d{2}:\d{2}$` and hour 0-23, minute 0-59.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm compilation. Run `npm run build` to ensure the route compiles in the Next.js build. Verify the route file exports GET and PUT.
  </verify>
  <done>
GET /api/mentorship/availability returns mentor's time slot availability and unavailable dates. PUT /api/mentorship/availability allows authenticated mentors to save their weekly schedule and override dates with validation. Both endpoints follow existing codebase patterns (auth, error handling, Firestore).
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npm run build` completes successfully
3. New types are importable: `import { TimeSlotAvailability, MentorBooking } from "@/types/mentorship"`
4. availability.ts functions are importable and have correct signatures
5. API route compiles and exports GET, PUT handlers
</verification>

<success_criteria>
- TimeSlotAvailability and MentorBooking types defined in mentorship.ts
- calculateAvailableSlots correctly generates slots respecting all filters
- GET /api/mentorship/availability returns mentor availability
- PUT /api/mentorship/availability saves availability with validation
- date-fns-tz installed for timezone handling
- All code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-mentor-time-slots-weekly-availability-management-mentee-booking-rescheduling-google-calendar-integration/12-01-SUMMARY.md`
</output>
