---
phase: 12-mentor-time-slots-weekly-availability-management-mentee-booking-rescheduling-google-calendar-integration
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - src/app/api/mentorship/time-slots/route.ts
  - src/app/api/mentorship/bookings/route.ts
autonomous: true

must_haves:
  truths:
    - "Mentee can view available time slots for a specific mentor within a date range"
    - "Mentee can book a 30-minute slot with atomic double-booking prevention"
    - "Mentor can cancel a booking and mentee receives Discord DM notification"
    - "Booked slots do not appear as available to other mentees"
  artifacts:
    - path: "src/app/api/mentorship/time-slots/route.ts"
      provides: "GET endpoint returning available slots for a mentor"
      exports: ["GET"]
    - path: "src/app/api/mentorship/bookings/route.ts"
      provides: "GET, POST, PUT endpoints for booking management"
      exports: ["GET", "POST", "PUT"]
  key_links:
    - from: "src/app/api/mentorship/time-slots/route.ts"
      to: "src/lib/availability.ts"
      via: "calls calculateAvailableSlots"
      pattern: "calculateAvailableSlots"
    - from: "src/app/api/mentorship/bookings/route.ts"
      to: "src/lib/discord.ts"
      via: "sends Discord DM on cancellation"
      pattern: "sendDirectMessage"
    - from: "src/app/api/mentorship/bookings/route.ts"
      to: "firebase-admin/firestore"
      via: "Firestore transaction for atomic booking"
      pattern: "db\\.runTransaction"
---

<objective>
Build the time slots query endpoint and the booking management API with Firestore transactions for double-booking prevention and Discord DM notifications for cancellations.

Purpose: Enable the core booking workflow - mentees can see available slots and book them, mentors can cancel with notification.
Output: Two API routes: time-slots (read) and bookings (create/read/cancel).
</objective>

<execution_context>
@/home/ahsan/.claude/get-shit-done/workflows/execute-plan.md
@/home/ahsan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-mentor-time-slots-weekly-availability-management-mentee-booking-rescheduling-google-calendar-integration/12-RESEARCH.md
@.planning/phases/12-mentor-time-slots-weekly-availability-management-mentee-booking-rescheduling-google-calendar-integration/12-01-SUMMARY.md
@src/types/mentorship.ts
@src/lib/availability.ts
@src/lib/auth.ts
@src/lib/discord.ts
@src/lib/firebaseAdmin.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create time-slots API route for querying available slots</name>
  <files>src/app/api/mentorship/time-slots/route.ts</files>
  <action>
Create `src/app/api/mentorship/time-slots/route.ts`:

**GET /api/mentorship/time-slots?mentorId={uid}&startDate={YYYY-MM-DD}&endDate={YYYY-MM-DD}**

Public endpoint (no auth required - mentees browse slots before deciding to book).

Implementation:
1. Validate required params: `mentorId`, `startDate`, `endDate`. Return 400 if missing.
2. Validate date format (YYYY-MM-DD regex). Validate endDate >= startDate. Validate range <= 14 days (prevent excessive queries).
3. Fetch mentor profile from `mentorship_profiles` where `uid == mentorId`:
   - Get `timeSlotAvailability` (TimeSlotAvailability) and `unavailableDates` (UnavailableDate[])
   - If no timeSlotAvailability set, return `{ slots: [], message: "Mentor has not set up availability" }`
4. Fetch existing confirmed bookings from `mentorship_bookings` collection:
   - Where `mentorId == mentorId` AND `status == "confirmed"`
   - Where `startTime >= startDate (as Date)` AND `startTime <= endDate + 1 day (as Date)`
   - Map to `{ startTime: Date, endTime: Date }` array
5. Use `getDaysInRange(startDate, endDate)` from availability.ts to get each day
6. For each day, call `calculateAvailableSlots(availability, unavailableDates, existingBookings, day)`
7. Flatten all slots, group by date for easier UI consumption:
   ```json
   {
     "slots": {
       "2026-02-15": [
         { "start": "2026-02-15T14:00:00.000Z", "end": "2026-02-15T14:30:00.000Z", "displayTime": "9:00 AM" },
         ...
       ],
       "2026-02-16": [...]
     },
     "timezone": "America/New_York",
     "slotDurationMinutes": 30
   }
   ```
8. Convert Firestore Timestamps to JS Dates for booking comparison.

Follow existing patterns: NextRequest/NextResponse, db from firebaseAdmin, try/catch, console.error.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Run `npm run build` to verify route compiles in Next.js.
  </verify>
  <done>
GET /api/mentorship/time-slots returns grouped available slots for a mentor within a date range, excluding booked slots, unavailable dates, and slots that violate advance booking constraints.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create bookings API route with transaction-based double-booking prevention and Discord cancellation DMs</name>
  <files>src/app/api/mentorship/bookings/route.ts</files>
  <action>
Create `src/app/api/mentorship/bookings/route.ts` with GET, POST, and PUT handlers:

**GET /api/mentorship/bookings?userId={uid}&role={mentor|mentee}&status={confirmed|cancelled|all}**
- Authenticated endpoint (verifyAuth)
- If role=mentor: query `mentorship_bookings` where `mentorId == userId`
- If role=mentee: query `mentorship_bookings` where `menteeId == userId`
- Default status filter: "confirmed" (only show active bookings)
- If status=all: return all bookings
- Order by startTime ascending
- Return bookings with profile data included
- Convert Firestore Timestamps to ISO strings in response

**POST /api/mentorship/bookings** (authenticated - mentee books a slot)
- Require auth via `verifyAuth(request)`
- Body: `{ mentorId: string, startTime: string (ISO), endTime: string (ISO), timezone: string }`
- Validate: mentorId exists, startTime/endTime are valid dates, endTime - startTime == 30 minutes, startTime is at least 2 hours in the future, startTime is within 60 days
- Verify the authenticated user is NOT the mentor (can't book own slots)
- Verify mentor profile exists and has timeSlotAvailability set
- **Use Firestore transaction for atomic booking:**
  ```typescript
  const bookingId = await db.runTransaction(async (transaction) => {
    // 1. Query existing confirmed bookings in this time window for the mentor
    const conflictsSnapshot = await transaction.get(
      db.collection("mentorship_bookings")
        .where("mentorId", "==", mentorId)
        .where("status", "==", "confirmed")
        .where("startTime", ">=", startTimeDate)
        .where("startTime", "<", endTimeDate)
    );

    if (!conflictsSnapshot.empty) {
      throw new Error("TIME_SLOT_ALREADY_BOOKED");
    }

    // 2. Create the booking
    const bookingRef = db.collection("mentorship_bookings").doc();
    transaction.set(bookingRef, {
      mentorId,
      menteeId: auth.uid,
      mentorProfile: { displayName, photoURL, username, discordUsername },
      menteeProfile: { displayName, photoURL, username, discordUsername },
      startTime: startTimeDate,
      endTime: endTimeDate,
      timezone,
      status: "confirmed",
      calendarEventId: null,
      calendarSyncStatus: "pending",
      createdAt: FieldValue.serverTimestamp(),
      updatedAt: FieldValue.serverTimestamp(),
    });

    return bookingRef.id;
  });
  ```
- Fetch both mentor and mentee profiles to populate the denormalized profile subsets
- Return 201 with the created booking
- If transaction throws "TIME_SLOT_ALREADY_BOOKED", return 409 Conflict with `{ error: "This time slot has already been booked" }`

**PUT /api/mentorship/bookings** (authenticated - cancel a booking)
- Require auth via `verifyAuth(request)`
- Body: `{ bookingId: string, action: "cancel", reason?: string }`
- Only action supported is "cancel" (reschedule = cancel + rebook per research decision)
- Fetch the booking document
- Verify the authenticated user is either the mentor or the mentee of this booking
- Verify booking status is "confirmed" (can't cancel already cancelled)
- Update booking: `status: "cancelled", cancelledBy: auth.uid, cancelledAt: new Date(), cancellationReason: reason || null, updatedAt: FieldValue.serverTimestamp()`
- **Send Discord DM notification** (non-blocking, following existing pattern):
  - If cancelled by mentor: DM the mentee's discordUsername
  - If cancelled by mentee: DM the mentor's discordUsername
  - Message format:
    ```
    **Session Cancelled**

    Your mentorship session on {formatted date} at {formatted time} ({timezone}) has been cancelled by {cancellerName}.
    {reason ? `Reason: ${reason}` : ''}

    Please visit the platform to reschedule: https://codewithahsan.dev/mentorship/dashboard
    ```
  - Use `sendDirectMessage(discordUsername, message)` from `@/lib/discord`
  - Wrap in try/catch, log error but don't fail the API response (non-blocking pattern from existing Discord integration)
- If booking has a `calendarEventId`, store it in the response so Plan 06 can handle calendar event deletion
- Return 200 with `{ success: true, calendarEventId: booking.calendarEventId || null }`

Import `{ sendDirectMessage, isDiscordConfigured }` from `@/lib/discord`. Use `FieldValue` from `firebase-admin/firestore` for server timestamps. Format dates using date-fns for the Discord notification message.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Run `npm run build` to verify route compiles. Verify the route exports GET, POST, PUT.
  </verify>
  <done>
GET returns bookings filtered by user role and status. POST creates a booking with Firestore transaction preventing double-booking (409 on conflict). PUT cancels a booking and sends non-blocking Discord DM to the affected party. All three handlers follow existing auth and error handling patterns.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds
3. time-slots route exports GET
4. bookings route exports GET, POST, PUT
5. POST /api/mentorship/bookings uses `db.runTransaction` for atomicity
6. PUT /api/mentorship/bookings calls `sendDirectMessage` for Discord notification
</verification>

<success_criteria>
- Available slots endpoint returns correct slots grouped by date
- Booking creation uses Firestore transaction to prevent double-booking
- Booking cancellation sends Discord DM to affected party
- All endpoints validate inputs and return appropriate error codes
- Non-blocking Discord pattern maintained (errors logged, not thrown)
</success_criteria>

<output>
After completion, create `.planning/phases/12-mentor-time-slots-weekly-availability-management-mentee-booking-rescheduling-google-calendar-integration/12-02-SUMMARY.md`
</output>
