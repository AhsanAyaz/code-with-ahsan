---
phase: 12-mentor-time-slots-weekly-availability-management-mentee-booking-rescheduling-google-calendar-integration
plan: 03
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - src/lib/google-calendar.ts
  - src/app/api/mentorship/calendar/auth/route.ts
  - src/app/api/mentorship/calendar/callback/route.ts
autonomous: true
user_setup:
  - service: google-calendar
    why: "Google Calendar API requires OAuth 2.0 credentials for creating/deleting events on mentor calendars"
    env_vars:
      - name: GOOGLE_CLIENT_ID
        source: "Google Cloud Console -> APIs & Services -> Credentials -> OAuth 2.0 Client ID"
      - name: GOOGLE_CLIENT_SECRET
        source: "Google Cloud Console -> APIs & Services -> Credentials -> OAuth 2.0 Client Secret"
      - name: GOOGLE_REDIRECT_URI
        source: "Set to https://codewithahsan.dev/api/mentorship/calendar/callback (or localhost:3000 for dev)"
      - name: GOOGLE_CALENDAR_ENCRYPTION_KEY
        source: "Generate a 32-character random string for encrypting refresh tokens (use: openssl rand -hex 16)"
    dashboard_config:
      - task: "Enable Google Calendar API"
        location: "Google Cloud Console -> APIs & Services -> Library -> Google Calendar API -> Enable"
      - task: "Create OAuth 2.0 credentials"
        location: "Google Cloud Console -> APIs & Services -> Credentials -> Create Credentials -> OAuth 2.0 Client ID -> Web Application"
      - task: "Add authorized redirect URI"
        location: "Google Cloud Console -> APIs & Services -> Credentials -> OAuth 2.0 Client ID -> Authorized redirect URIs -> Add https://codewithahsan.dev/api/mentorship/calendar/callback"

must_haves:
  truths:
    - "Google Calendar OAuth 2.0 flow allows mentor to connect their calendar"
    - "OAuth callback exchanges code for tokens and stores encrypted refresh token"
    - "Calendar events can be created with Google Meet link for bookings"
    - "Calendar events can be deleted when bookings are cancelled"
  artifacts:
    - path: "src/lib/google-calendar.ts"
      provides: "OAuth client factory, token encryption, create/delete event functions"
      exports: ["getOAuthClient", "getAuthUrl", "exchangeCodeForTokens", "createCalendarEvent", "deleteCalendarEvent", "encryptToken", "decryptToken"]
    - path: "src/app/api/mentorship/calendar/auth/route.ts"
      provides: "GET endpoint redirecting mentor to Google OAuth consent screen"
      exports: ["GET"]
    - path: "src/app/api/mentorship/calendar/callback/route.ts"
      provides: "GET endpoint handling OAuth callback, storing tokens"
      exports: ["GET"]
  key_links:
    - from: "src/lib/google-calendar.ts"
      to: "googleapis"
      via: "uses google.auth.OAuth2 and google.calendar"
      pattern: "import.*google.*from.*googleapis"
    - from: "src/app/api/mentorship/calendar/callback/route.ts"
      to: "src/lib/google-calendar.ts"
      via: "exchanges code for tokens and stores in Firestore"
      pattern: "exchangeCodeForTokens"
---

<objective>
Implement Google Calendar OAuth 2.0 integration: library for OAuth flows, token management with encryption, and calendar event create/delete operations. Plus the auth and callback API routes for the OAuth handshake.

Purpose: Enable programmatic Google Calendar access so bookings automatically create calendar events with Google Meet links, and cancellations delete them.
Output: google-calendar.ts library module, OAuth auth route, and OAuth callback route.
</objective>

<execution_context>
@/home/ahsan/.claude/get-shit-done/workflows/execute-plan.md
@/home/ahsan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-mentor-time-slots-weekly-availability-management-mentee-booking-rescheduling-google-calendar-integration/12-RESEARCH.md
@.planning/phases/12-mentor-time-slots-weekly-availability-management-mentee-booking-rescheduling-google-calendar-integration/12-01-SUMMARY.md
@src/types/mentorship.ts
@src/lib/auth.ts
@src/lib/firebaseAdmin.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Google Calendar library with OAuth, encryption, and event management</name>
  <files>src/lib/google-calendar.ts</files>
  <action>
Create `src/lib/google-calendar.ts` with the following exports:

**Configuration check:**
```typescript
export function isCalendarConfigured(): boolean {
  return !!(process.env.GOOGLE_CLIENT_ID && process.env.GOOGLE_CLIENT_SECRET && process.env.GOOGLE_REDIRECT_URI);
}
```

**OAuth client factory:**
```typescript
import { google } from "googleapis";

export function getOAuthClient() {
  return new google.auth.OAuth2(
    process.env.GOOGLE_CLIENT_ID,
    process.env.GOOGLE_CLIENT_SECRET,
    process.env.GOOGLE_REDIRECT_URI
  );
}
```

**Auth URL generation:**
```typescript
export function getAuthUrl(mentorId: string): string {
  const client = getOAuthClient();
  return client.generateAuthUrl({
    access_type: "offline",
    prompt: "consent", // Force consent to always get refresh_token
    scope: ["https://www.googleapis.com/auth/calendar.events"],
    state: mentorId, // Pass mentorId through OAuth flow
  });
}
```

**Token exchange:**
```typescript
export async function exchangeCodeForTokens(code: string) {
  const client = getOAuthClient();
  const { tokens } = await client.getToken(code);
  return tokens;
}
```

**Token encryption** (using Node.js built-in crypto):
```typescript
import { createCipheriv, createDecipheriv, randomBytes } from "crypto";

const ALGORITHM = "aes-256-gcm";

export function encryptToken(token: string): string {
  const key = Buffer.from(process.env.GOOGLE_CALENDAR_ENCRYPTION_KEY || "", "hex");
  const iv = randomBytes(16);
  const cipher = createCipheriv(ALGORITHM, key, iv);
  let encrypted = cipher.update(token, "utf8", "hex");
  encrypted += cipher.final("hex");
  const authTag = cipher.getAuthTag().toString("hex");
  return `${iv.toString("hex")}:${authTag}:${encrypted}`;
}

export function decryptToken(encryptedData: string): string {
  const key = Buffer.from(process.env.GOOGLE_CALENDAR_ENCRYPTION_KEY || "", "hex");
  const [ivHex, authTagHex, encrypted] = encryptedData.split(":");
  const iv = Buffer.from(ivHex, "hex");
  const authTag = Buffer.from(authTagHex, "hex");
  const decipher = createDecipheriv(ALGORITHM, key, iv);
  decipher.setAuthTag(authTag);
  let decrypted = decipher.update(encrypted, "hex", "utf8");
  decrypted += decipher.final("utf8");
  return decrypted;
}
```

**Get authenticated calendar client for a mentor:**
```typescript
import { db } from "@/lib/firebaseAdmin";

export async function getMentorCalendarClient(mentorId: string) {
  const profileQuery = await db.collection("mentorship_profiles")
    .where("uid", "==", mentorId)
    .limit(1)
    .get();

  if (profileQuery.empty) throw new Error("Mentor profile not found");

  const profile = profileQuery.docs[0].data();
  if (!profile.googleCalendarRefreshToken) {
    return null; // Calendar not connected
  }

  const client = getOAuthClient();
  const refreshToken = decryptToken(profile.googleCalendarRefreshToken);
  client.setCredentials({ refresh_token: refreshToken });

  // Listen for token refresh and update stored token
  client.on("tokens", async (tokens) => {
    if (tokens.refresh_token) {
      await profileQuery.docs[0].ref.update({
        googleCalendarRefreshToken: encryptToken(tokens.refresh_token),
      });
    }
  });

  return client;
}
```

**Create calendar event:**
```typescript
export async function createCalendarEvent(
  mentorId: string,
  booking: {
    id: string;
    startTime: Date;
    endTime: Date;
    timezone: string;
    menteeName: string;
    menteeEmail?: string;
  }
): Promise<string | null> {
  const authClient = await getMentorCalendarClient(mentorId);
  if (!authClient) return null;

  const calendar = google.calendar({ version: "v3", auth: authClient });

  const event = {
    summary: `Mentorship Session with ${booking.menteeName}`,
    description: `Mentorship session booked via Code with Ahsan platform.\n\nBooking ID: ${booking.id}`,
    start: {
      dateTime: booking.startTime.toISOString(),
      timeZone: booking.timezone,
    },
    end: {
      dateTime: booking.endTime.toISOString(),
      timeZone: booking.timezone,
    },
    attendees: booking.menteeEmail ? [{ email: booking.menteeEmail }] : [],
    conferenceData: {
      createRequest: {
        requestId: `booking-${booking.id}`,
        conferenceSolutionKey: { type: "hangoutsMeet" },
      },
    },
    reminders: {
      useDefault: false,
      overrides: [
        { method: "email", minutes: 60 },
        { method: "popup", minutes: 15 },
      ],
    },
  };

  const response = await calendar.events.insert({
    calendarId: "primary",
    conferenceDataVersion: 1,
    resource: event,
    sendUpdates: "all",
  });

  return response.data.id || null;
}
```

**Delete calendar event:**
```typescript
export async function deleteCalendarEvent(
  mentorId: string,
  eventId: string
): Promise<boolean> {
  const authClient = await getMentorCalendarClient(mentorId);
  if (!authClient) return false;

  const calendar = google.calendar({ version: "v3", auth: authClient });

  await calendar.events.delete({
    calendarId: "primary",
    eventId,
    sendUpdates: "all", // Send cancellation emails to attendees
  });

  return true;
}
```

Add JSDoc comments to all exported functions. Add a `createLogger("google-calendar")` for structured logging (import from `@/lib/logger`). Wrap all external API calls in try/catch and log errors.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Verify that googleapis types resolve correctly (the package is already installed at v169).
  </verify>
  <done>
google-calendar.ts exports OAuth client factory, auth URL generation, token exchange, AES-256-GCM token encryption/decryption, authenticated calendar client retrieval with auto-refresh, event creation with Google Meet, and event deletion with attendee notifications. All errors are logged via structured logger.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Google Calendar OAuth auth and callback API routes</name>
  <files>src/app/api/mentorship/calendar/auth/route.ts, src/app/api/mentorship/calendar/callback/route.ts</files>
  <action>
**Create `src/app/api/mentorship/calendar/auth/route.ts`:**

GET /api/mentorship/calendar/auth - Initiates OAuth flow

- Authenticated endpoint (verifyAuth)
- Verify the user is a mentor (check mentorship_profiles where uid matches and role == "mentor")
- Check `isCalendarConfigured()` - return 503 if not configured with `{ error: "Google Calendar integration not configured" }`
- Generate OAuth URL using `getAuthUrl(auth.uid)`
- Return `{ authUrl }` - client will redirect to this URL

**Create `src/app/api/mentorship/calendar/callback/route.ts`:**

GET /api/mentorship/calendar/callback?code={code}&state={mentorId} - OAuth callback

- This is a browser redirect endpoint (not API-called), so it returns a redirect, not JSON
- Extract `code` and `state` (mentorId) from query params
- Validate both are present
- Exchange code for tokens using `exchangeCodeForTokens(code)`
- Encrypt the refresh_token using `encryptToken(tokens.refresh_token)`
- Update the mentor's profile document in Firestore:
  ```typescript
  await db.collection("mentorship_profiles")
    .where("uid", "==", mentorId)
    .limit(1)
    .get()
    .then(snap => {
      if (!snap.empty) {
        snap.docs[0].ref.update({
          googleCalendarRefreshToken: encryptedRefreshToken,
          googleCalendarConnected: true,
          googleCalendarConnectedAt: new Date(),
        });
      }
    });
  ```
- Redirect the user back to the profile/availability page:
  ```typescript
  return NextResponse.redirect(new URL("/profile?calendar=connected", request.url));
  ```
- On error, redirect with error param: `return NextResponse.redirect(new URL("/profile?calendar=error", request.url));`
- If `tokens.refresh_token` is null/undefined (happens when user already granted access before), return error redirect with message: `?calendar=error&reason=no_refresh_token`

Note: The callback URL must match exactly what's configured in Google Cloud Console. The `state` parameter passes the mentorId safely through the OAuth flow (Google passes it back unchanged).

Follow existing API patterns. Use console.error for error logging.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Run `npm run build` to verify both routes compile. Verify the auth route exports GET, callback route exports GET.
  </verify>
  <done>
Auth route returns Google OAuth consent URL for authenticated mentors. Callback route exchanges OAuth code for tokens, encrypts refresh token, stores in Firestore, and redirects user back to profile page with success/error status. Token auto-refresh is handled by the library.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds
3. google-calendar.ts exports all expected functions
4. Auth route exports GET and returns authUrl
5. Callback route exports GET and handles OAuth code exchange
6. Encryption roundtrip works (encrypt then decrypt returns original)
</verification>

<success_criteria>
- Google Calendar library handles full OAuth lifecycle
- Token encryption uses AES-256-GCM (not plaintext)
- Calendar events created with Google Meet conferencing
- Calendar events deleted with attendee notifications
- OAuth callback stores encrypted tokens in Firestore
- OAuth callback redirects back to profile page
- Graceful handling when calendar not configured (isCalendarConfigured)
</success_criteria>

<output>
After completion, create `.planning/phases/12-mentor-time-slots-weekly-availability-management-mentee-booking-rescheduling-google-calendar-integration/12-03-SUMMARY.md`
</output>
