---
phase: 08-roadmaps-creation-admin
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/roadmaps/route.ts
  - src/app/api/roadmaps/[id]/route.ts
  - src/app/api/roadmaps/[id]/versions/route.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/roadmaps creates a roadmap document in Firestore with metadata and uploads sanitized Markdown to Firebase Storage"
    - "GET /api/roadmaps returns roadmaps filtered by status and/or creatorId"
    - "PUT /api/roadmaps/[id] supports submit, approve, request-changes, and edit actions with permission checks"
    - "GET /api/roadmaps/[id] returns full roadmap details including content fetched from Storage"
    - "GET /api/roadmaps/[id]/versions returns version history ordered by version number descending"
    - "Editing an approved roadmap creates a new version in the subcollection and resets status to pending"
  artifacts:
    - path: "src/app/api/roadmaps/route.ts"
      provides: "POST (create roadmap) and GET (list roadmaps) endpoints"
      exports: ["POST", "GET"]
    - path: "src/app/api/roadmaps/[id]/route.ts"
      provides: "GET (single roadmap with content) and PUT (submit/approve/decline/edit) endpoints"
      exports: ["GET", "PUT"]
    - path: "src/app/api/roadmaps/[id]/versions/route.ts"
      provides: "GET (version history) endpoint"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/roadmaps/route.ts"
      to: "Firebase Storage"
      via: "storage.bucket().file().save() for Markdown upload"
      pattern: "storage\\.bucket|file\\.save"
    - from: "src/app/api/roadmaps/route.ts"
      to: "src/lib/validation/sanitize.ts"
      via: "sanitizeMarkdownRaw before upload"
      pattern: "sanitizeMarkdownRaw"
    - from: "src/app/api/roadmaps/[id]/route.ts"
      to: "src/lib/permissions.ts"
      via: "canCreateRoadmap, canApproveRoadmap, canEditRoadmap checks"
      pattern: "canCreateRoadmap|canApproveRoadmap|canEditRoadmap"
    - from: "src/app/api/roadmaps/route.ts"
      to: "src/lib/auth.ts"
      via: "verifyAuth for authentication"
      pattern: "verifyAuth"
---

<objective>
Create all backend API routes for roadmap CRUD operations with Firebase Storage integration for Markdown content persistence, version history tracking, and admin approval workflow.

Purpose: Provides the backend foundation that both the roadmap creation form and admin approval UI depend on. Follows established patterns from projects API routes (Phase 5).
Output: Three API route files handling roadmap lifecycle (create, list, get, submit, approve, decline, edit, version history).
</objective>

<execution_context>
@/Users/amu1o5/.claude/get-shit-done/workflows/execute-plan.md
@/Users/amu1o5/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-roadmaps-creation-admin/08-RESEARCH.md

# Key references for implementation patterns
@src/app/api/projects/route.ts
@src/app/api/projects/[id]/route.ts
@src/lib/auth.ts
@src/lib/firebaseAdmin.ts
@src/lib/permissions.ts
@src/lib/validation/sanitize.ts
@src/types/mentorship.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create roadmap collection and list API routes (POST + GET /api/roadmaps)</name>
  <files>src/app/api/roadmaps/route.ts</files>
  <action>
Create `src/app/api/roadmaps/route.ts` with POST and GET handlers following the exact pattern from `src/app/api/projects/route.ts`.

**POST /api/roadmaps** (create roadmap):
1. Call `verifyAuth(request)` - return 401 if null (same pattern as projects route.ts line 12)
2. Parse body: `{ title, description, domain, difficulty, estimatedHours, content }`
3. Validate required fields:
   - `title`: required string, 3-100 characters
   - `domain`: required, must be one of the RoadmapDomain values: "web-dev", "frontend", "backend", "ml", "ai", "mcp", "agents", "prompt-engineering"
   - `difficulty`: required, must be one of: "beginner", "intermediate", "advanced"
   - `content`: required string, minimum 50 characters (roadmap body must be substantive)
   - `estimatedHours`: optional number, if provided must be > 0 and <= 1000
   - `description`: optional string, max 500 characters (short summary for listings)
4. Fetch creator profile from `mentorship_profiles` collection using `authResult.uid`
5. Check `canCreateRoadmap()` from permissions.ts - return 403 if false (only accepted mentors)
6. Sanitize content: `sanitizeMarkdownRaw(content)` from `src/lib/validation/sanitize.ts`
7. Create Firestore document in `roadmaps` collection with:
   ```
   {
     title, description: description || "",
     domain, difficulty,
     estimatedHours: estimatedHours || null,
     creatorId: authResult.uid,
     creatorProfile: { displayName, photoURL, username } (from mentorship_profiles),
     status: "draft",
     version: 1,
     contentUrl: null, // updated after upload
     createdAt: FieldValue.serverTimestamp(),
     updatedAt: FieldValue.serverTimestamp(),
   }
   ```
8. Upload sanitized content to Firebase Storage:
   - Path: `roadmaps/{docId}/v1-{Date.now()}.md`
   - Use `storage` export from firebaseAdmin.ts (it's already `admin.storage().bucket(...)`)
   - `const file = storage.file(storagePath);`
   - `await file.save(sanitizedContent, { contentType: "text/markdown", metadata: { metadata: { version: "1", roadmapId: docRef.id } } });`
   - `await file.makePublic();`
   - `const contentUrl = file.publicUrl();`
9. Update Firestore doc with contentUrl
10. Create initial version in subcollection `roadmaps/{docId}/versions`:
    ```
    { roadmapId: docRef.id, version: 1, contentUrl, createdBy: authResult.uid, createdAt: FieldValue.serverTimestamp(), changeDescription: "Initial version" }
    ```
    NOTE: Store contentUrl in version docs (not full content) to keep Firestore docs small. The version references the same Storage file.
11. Return `{ success: true, id: docRef.id }` with 201

**GET /api/roadmaps** (list roadmaps):
1. Parse query params: `status`, `creatorId` from `request.nextUrl.searchParams`
2. Build Firestore query on `roadmaps` collection:
   - If `status` provided: `.where("status", "==", status)`
   - If `creatorId` provided: `.where("creatorId", "==", creatorId)`
   - Order by `createdAt` descending
   - Limit to 50
3. Execute query, map results converting Firestore Timestamps to ISO strings (same pattern as projects GET):
   - `createdAt`, `updatedAt`, `approvedAt` -> `.toDate().toISOString()`
4. Return `{ roadmaps: [...] }` with 200

Import `verifyAuth` from `@/lib/auth`, `db, storage` from `@/lib/firebaseAdmin`, `FieldValue` from `firebase-admin/firestore`, `canCreateRoadmap` from `@/lib/permissions`, `sanitizeMarkdownRaw` from `@/lib/validation/sanitize`, `PermissionUser` type from `@/lib/permissions`.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles without errors.
Verify file exists and exports POST and GET functions.
  </verify>
  <done>
POST /api/roadmaps creates roadmap with sanitized Markdown in Storage and metadata in Firestore.
GET /api/roadmaps returns filtered roadmap list with proper timestamp serialization.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create roadmap detail, actions, and version history API routes</name>
  <files>
    src/app/api/roadmaps/[id]/route.ts
    src/app/api/roadmaps/[id]/versions/route.ts
  </files>
  <action>
**File 1: `src/app/api/roadmaps/[id]/route.ts`** with GET and PUT handlers following `src/app/api/projects/[id]/route.ts` pattern.

**GET /api/roadmaps/[id]** (single roadmap detail):
1. Extract `id` from `await params` (Next.js 16 pattern: `{ params }: { params: Promise<{ id: string }> }`)
2. Fetch roadmap doc from Firestore
3. If not found, return 404
4. If roadmap has `contentUrl`, fetch the Markdown content from that URL using `fetch(contentUrl)` and include as `content` field in response
5. Convert Firestore timestamps to ISO strings
6. Return `{ roadmap: { id, ...data, content } }` with 200

**PUT /api/roadmaps/[id]** (roadmap actions):
1. Call `verifyAuth(request)` - return 401 if null
2. Extract `id` from `await params`
3. Parse body: `{ action, feedback, title, description, domain, difficulty, estimatedHours, content, changeDescription }`
4. Fetch roadmap doc - return 404 if not found
5. Fetch actor's mentorship_profiles doc for permission checks
6. Build PermissionUser from profile data

Handle actions:

**action === "submit"** (mentor submits draft for admin review):
- Verify roadmap.status is "draft" - return 400 if not
- Verify `authResult.uid === roadmapData.creatorId` (only creator can submit their draft) - return 403 if not
- Update: `{ status: "pending", updatedAt: FieldValue.serverTimestamp() }`
- Return `{ success: true, message: "Roadmap submitted for review" }`

**action === "approve"** (admin approves):
- Check `canApproveRoadmap(permissionUser, roadmap)` - return 403 if false
- Verify roadmap.status is "pending" - return 400 if not
- Update: `{ status: "approved", approvedAt: FieldValue.serverTimestamp(), approvedBy: authResult.uid, updatedAt: FieldValue.serverTimestamp() }`
- Return `{ success: true, message: "Roadmap approved" }`

**action === "request-changes"** (admin requests changes with feedback):
- Check `canApproveRoadmap(permissionUser, roadmap)` - return 403 if false
- Verify roadmap.status is "pending" - return 400 if not
- Require `feedback` string, minimum 10 characters - return 400 if missing/short
- Update: `{ status: "draft", feedback, feedbackAt: FieldValue.serverTimestamp(), feedbackBy: authResult.uid, updatedAt: FieldValue.serverTimestamp() }`
- Return `{ success: true, message: "Changes requested" }`

**action === "edit"** (mentor edits roadmap, creates new version):
- Check `canEditRoadmap(permissionUser, roadmapAsType)` - return 403 if false (owner or admin)
- Construct roadmap-like object: `{ creatorId: roadmapData.creatorId }` for the permission check
- Require `content` string, minimum 50 chars - return 400 if missing
- Calculate `newVersion = (roadmapData.version || 1) + 1`
- Sanitize content: `sanitizeMarkdownRaw(content)`
- Upload to Storage: path `roadmaps/{id}/v{newVersion}-{Date.now()}.md`
- Make public, get contentUrl
- Update main doc: `{ contentUrl, version: newVersion, status: "draft", updatedAt: FieldValue.serverTimestamp(), ...optionalFieldUpdates }` where optional fields are title, description, domain, difficulty, estimatedHours if provided
- Create version in subcollection: `{ roadmapId: id, version: newVersion, contentUrl, createdBy: authResult.uid, createdAt: FieldValue.serverTimestamp(), changeDescription: changeDescription || "Version " + newVersion }`
- Return `{ success: true, message: "Roadmap updated", version: newVersion }`

For any unrecognized action, return `{ error: "Invalid action" }` with 400.

**File 2: `src/app/api/roadmaps/[id]/versions/route.ts`** with GET handler.

**GET /api/roadmaps/[id]/versions** (version history):
1. Extract `id` from `await params`
2. Query subcollection: `db.collection("roadmaps").doc(id).collection("versions").orderBy("version", "desc")`
3. Map results, converting Firestore timestamps to ISO strings
4. Return `{ versions: [...] }` with 200

Imports for both files: Same pattern as projects/[id]/route.ts - `NextRequest`, `NextResponse`, `db, storage` from firebaseAdmin, `FieldValue`, `verifyAuth`, `canApproveRoadmap`, `canEditRoadmap` from permissions, `sanitizeMarkdownRaw` from sanitize, `PermissionUser` type.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles without errors.
Verify both files exist and export the correct handler functions.
Run `npm run build` to verify no build errors.
  </verify>
  <done>
GET /api/roadmaps/[id] returns roadmap with content fetched from Storage.
PUT /api/roadmaps/[id] handles submit, approve, request-changes, and edit actions with permission checks.
GET /api/roadmaps/[id]/versions returns version history ordered by version descending.
Editing creates a new version and resets status to draft for re-approval.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes - all types correct
2. `npm run build` succeeds - no SSR/build errors
3. All three route files exist with correct exports:
   - `src/app/api/roadmaps/route.ts` exports POST, GET
   - `src/app/api/roadmaps/[id]/route.ts` exports GET, PUT
   - `src/app/api/roadmaps/[id]/versions/route.ts` exports GET
4. POST uses sanitizeMarkdownRaw before uploading to Storage
5. POST uses verifyAuth and canCreateRoadmap permission check
6. PUT approve/request-changes use canApproveRoadmap permission check
7. PUT edit uses canEditRoadmap permission check and creates version subcollection entry
</verification>

<success_criteria>
- Roadmap creation stores sanitized Markdown in Firebase Storage and metadata in Firestore
- Roadmap listing supports status and creatorId filters
- Single roadmap detail includes content fetched from Storage URL
- Admin can approve or request changes on pending roadmaps
- Edit action creates new version, uploads new content to Storage, resets status to draft
- Version history returns chronological version entries
- All mutating endpoints verify authentication via verifyAuth
- All actions enforce role-based permissions (mentor creates, admin approves, owner/admin edits)
</success_criteria>

<output>
After completion, create `.planning/phases/08-roadmaps-creation-admin/08-01-SUMMARY.md`
</output>
